<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>推荐算法</title>
    <link href="/2020/07/10/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/10/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h1><p>Apriori关联分析算法</p><ul><li>无监督</li><li>挖掘关联</li><li>数据集很大时，运行效率低（故用FP-Growth优化）</li></ul><p>Apriori（支持度） 组合购买数不大于 支持度 就被淘汰</p><img src="https://s1.ax1x.com/2020/07/11/UlpcBd.png" srcset="/img/loading.gif" alt="image-20200710171215225" style="zoom:50%;"><p>下图购买人数全部大于<em>支持度*</em>2，故都不淘汰</p><img src="https://s1.ax1x.com/2020/07/11/Ulp6nH.png" srcset="/img/loading.gif" alt="image-20200710171603664" style="zoom:50%;"><img src="https://s1.ax1x.com/2020/07/11/UlprcD.png" srcset="/img/loading.gif" alt="image-20200710171915364" style="zoom: 50%;"><img src="https://s1.ax1x.com/2020/07/11/UlpgHA.png" srcset="/img/loading.gif" alt="image-20200710172746753" style="zoom:33%;"><img src="https://s1.ax1x.com/2020/07/11/UlpIgS.png" srcset="/img/loading.gif" alt="image-20200710172930999" style="zoom: 33%;"><ul><li>缺点<ul><li>数据稀疏性和冷启动问题</li></ul></li><li>优点<ul><li>挖掘用户的潜在兴趣</li><li>仅仅需要评分矩阵来训练矩阵分解模型</li></ul></li></ul><img src="https://s1.ax1x.com/2020/07/11/UlpRAI.png" srcset="/img/loading.gif" alt="image-20200710173159077" style="zoom: 33%;"><h2 id="推荐系统常见的问题"><a href="#推荐系统常见的问题" class="headerlink" title="推荐系统常见的问题"></a>推荐系统常见的问题</h2><ul><li><p>冷启动（数据问题）</p><ul><li>用户冷启动→新用户</li><li>物品冷启动→新物品</li><li>系统冷启动→新系统</li><li>根据注册信息 进行分类（邮箱  性别  手机号码）</li><li>推荐热门的排行榜</li><li>基于深度学习的语义理解模型</li><li>引导用户把属性表达出来</li><li>利用用户在社交媒体的信息</li></ul></li></ul><ul><li><p>数据稀疏（算法优化的问题）</p></li><li><p>不断变化的用户喜好</p></li><li><p>不可预知的事项（千人千面）</p></li></ul><p>物品冷启动：</p><img src="https://s1.ax1x.com/2020/07/11/UlpWNt.png" srcset="/img/loading.gif" alt="image-20200710174356337" style="zoom:33%;"><p>离线实验：数据集上完成试验</p><p>A/B Test在线实验  分几组  每组进入不同模型</p><p>用户调研和反馈</p><h3 id="A-B-Test在线实验"><a href="#A-B-Test在线实验" class="headerlink" title="A/B Test在线实验"></a>A/B Test在线实验</h3><ul><li>A/B Test 在线实验是以正交分桶为基础（随机将用户划分几组）</li><li>根据分桶执行不同的算法得出差异化的指标</li><li>取其中较优的算法</li></ul><img src="https://s1.ax1x.com/2020/07/11/Ulpf4P.png" srcset="/img/loading.gif" alt="image-20200710182636242" style="zoom: 33%;"><h3 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h3><img src="https://s1.ax1x.com/2020/07/11/Ulp49f.png" srcset="/img/loading.gif" alt="image-20200710183853321" style="zoom: 33%;"><img src="https://s1.ax1x.com/2020/07/11/Ulp538.png" srcset="/img/loading.gif" alt="image-20200710183931312" style="zoom: 50%;"><img src="https://s1.ax1x.com/2020/07/11/Ulpojg.png" srcset="/img/loading.gif" alt="image-20200710184106335" style="zoom: 50%;"><img src="https://s1.ax1x.com/2020/07/11/UlpHBj.png" srcset="/img/loading.gif" alt="image-20200711120707348" style="zoom:67%;"><img src="https://s1.ax1x.com/2020/07/11/Ulp7uQ.png" srcset="/img/loading.gif" alt="image-20200711120752003" style="zoom:50%;"><h3 id="关于scipy下leastsq-的一个问题"><a href="#关于scipy下leastsq-的一个问题" class="headerlink" title="关于scipy下leastsq()的一个问题"></a>关于scipy下leastsq()的一个问题</h3><p>leastsq是scipy库下求通过最小二乘法求函数系数的一个函数</p><pre><code class="python">scipy.optimize.leastsq(func,x0,args=())  #常用形式</code></pre><p>func 是 指误差函数，如下</p><pre><code class="python">def errors(p,x,y):    _y = function(p,x)    return y-_y</code></pre><p>而上面errors函数中的function指的是要拟合的函数曲线：</p><pre><code>def function(p,x):    a,b=p    y=a*x+b    return y</code></pre><p>在leastsq()的使用过程中需要注意一个问题</p><p>如下函数</p><pre><code class="python">def function(x,p):    a,b=p    y=a*x+b    return ydef errors(x,y,p):    _y = function(x,p)    return y-_yleastsq(errors,[1,1],args=[x,y])</code></pre><p>会使得errors(x=[1,1],y=leastsq中的x,p=leastsq中的y)</p><p>因此会报错 <strong>too many values to unpack (expected 2)</strong></p><p>因此顺序问题应该注意，正确写法如下</p><pre><code class="python">def errors(p,x,y):    _y = function(p,x)    return y-_ydef function(p,x):    a,b=p    y=a*x+b    return y</code></pre>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥悲卑</title>
    <link href="/2020/03/19/%E5%8A%A8%E6%80%81%E7%AD%96%E5%88%92/"/>
    <url>/2020/03/19/%E5%8A%A8%E6%80%81%E7%AD%96%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态策划"><a href="#动态策划" class="headerlink" title="动态策划"></a>动态策划</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>棋盘上 A<em>A</em> 点有一个过河卒，需要走到目标 B<em>B</em> 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C<em>C</em> 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，A<em>A</em> 点 (0, 0)(0,0)、B<em>B</em> 点 (n, m)(<em>n</em>,<em>m</em>)，同样马的位置坐标是需要给出的。</p><p><img src="https://s1.ax1x.com/2020/03/18/8we5VO.png" srcset="/img/loading.gif" alt="img"></p><p>现在要求你计算出卒从 A<em>A</em> 点能够到达 B<em>B</em> 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行四个正整数，分别表示 B<em>B</em> 点坐标和马的坐标。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示所有的路径条数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><pre><code>6 6 3 3</code></pre><p><strong>输出 #1</strong>复制</p><pre><code>6</code></pre><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于 100% 的数据，1 ≤ n, m ≤ 20，0 ≤ 马的坐标 ≤20。</p><h2 id="再给几组测试数据"><a href="#再给几组测试数据" class="headerlink" title="再给几组测试数据"></a>再给几组测试数据</h2><p><strong>输入 #1</strong>复制</p><pre><code>12 20 5 7</code></pre><p><strong>输出 #1</strong>复制</p><pre><code>24357120</code></pre><p><strong>输入 #1</strong>复制</p><pre><code>20 20 10 10</code></pre><p><strong>输出 #1</strong>复制</p><pre><code>21388094780</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code class="c++">#include&lt;iostream&gt;using namespace std;long long fun(long long n,long long m,long long x,long long y){    long long a[21][21];    int dx[9] = {0,2,2,1,1,-2,-2,-1,-1};    int dy[9] = {0,1,-1,2,-2,1,-1,2,-2};    bool g1[21][21];    fill(g1[0],g1[0]+21*21,true);    int i,g,h;    for(i=0;i&lt;=8;i++){        int xx=x+dx[i],yy=y+dy[i];        if(xx&gt;=0&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=0&amp;&amp;yy&lt;=m){            g1[xx][yy]=false;        }    }    fill(a[0],a[0]+21*21,0);    a[0][0]=1LL;    for(g=0; g&lt;=n; g++)    {        for(h=0;h&lt;=m;h++)        {            if(g1[g][h]){                if(g==0&amp;&amp;h&gt;=1){                    a[0][h]=a[0][h-1];                 }                if(h==0&amp;&amp;g&gt;=1){                    a[g][0]=a[g-1][0];                 }                if(g&gt;=1&amp;&amp;h&gt;=1){                       a[g][h] = a[g-1][h]+a[g][h-1];                }             }        }    }    return a[n][m];}int main(){    long long n,m,x,y;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;    cout&lt;&lt;fun(n,m,x,y)&lt;&lt;endl;    return 0;}</code></pre><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯杯杯</title>
    <link href="/2020/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%9D%AF%E6%9D%AF%E6%9D%AF/"/>
    <url>/2020/03/15/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%9D%AF%E6%9D%AF%E6%9D%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="1-读题"><a href="#1-读题" class="headerlink" title="1.读题"></a>1.读题</h2><blockquote><p>不要放过任何一个细节  这对规避一些问题以及寻找思路有很大的帮助</p></blockquote><p>例题：作为篮球队教练，你需要从名单中选出 1 号位至 5 号位各一名球员， 组成球队的首发阵容。<br>每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1 号位至 5 号位的评分之和最大可能是多少?<br><img src="https://s1.ax1x.com/2020/03/18/8weoIe.png" srcset="/img/loading.gif" alt></p><p>编号1~20为球员，后面紧跟的5个数值是其在5个位置的表现，一个球员只能担任一个位置，所以<strong>在选取该球员时应该综合考虑</strong>，如17号很出色在1 3 4 号位都为最高分，但综合考虑 应该让其担任3号位，因为17号3号位分数最好。</p><p>此题可以通过观察与口算得出：  </p><p>97(1)+99(10/20) + 99(17)+97(15)+98(18/12)</p><p>490</p><p>当然仔细观察还有更多的解法，此题只是想说明读题的重要性</p><h2 id="2-理清楚思路"><a href="#2-理清楚思路" class="headerlink" title="2.理清楚思路"></a>2.理清楚思路</h2><p>想清楚用什么知识点，将步骤一步步写出来</p><p>例题：</p><p>试题 G: 完全二叉树的权值</p><p>时间限制: 1.0s 内存限制: 256.0MB</p><p> 本题总分：20 分 </p><p>【问题描述】</p><p> 给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从 上到下、从左到右的顺序依次是 A 1 , A 2 , ··· A N ，如下图所示： 现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点 权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。 注：根的深度是 1。</p><p>【输入格式】 </p><p>第一行包含一个整数 N。 </p><p>第二行包含 N 个整数 A 1 , A 2 , ··· A N 。 </p><p>【输出格式】</p><p> 输出一个整数代表答案。 </p><p>【样例输入】 </p><p>7 1 6 5 4 3 2 1 </p><p>【样例输出】 </p><p>2 </p><p>【评测用例规模与约定】 </p><p>对于所有评测用例，1 ≤ N ≤ 100000，−100000 ≤ A i ≤ 100000。</p><p><strong>知识点：</strong></p><p>完全二叉树第i层的最大节点数为<code>2^(i-1)</code>个</p><p>深度为 n 的完全二叉树最多拥有 <code>2^n - 1</code> 个节点</p><p>层数为17的完全二叉树最多拥有2^17-1=131071个结点，题目要求N&lt;=100000</p><p><strong>步骤：</strong></p><ol><li>首先肯定是要写出能够代表或者获取树深度的函数  getdeep()</li><li>考虑如何存储权值并计算一层中权值的总和</li><li>对总和进行排序后的输出</li></ol><p>代码：</p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int getdeep(int n){    int result=0;    while(n&gt;0){        n=n/2;        result++;    }    return result;}int main(){    int weight[18]={0},n;    cin&gt;&gt;n;    int i=1,quanzhi,max,cengshu=1;    for(i=1;i&lt;=n;i++){        int point=getdeep(i);        scanf(&quot;%d&quot;,&amp;quanzhi);        weight[point]+=quanzhi;        if(i==1){            max=weight[1];        }        if(weight[point]&gt;=max){            max=weight[point];            cengshu=point;        }    }    cout&lt;&lt;cengshu&lt;&lt;endl;    return 0;}</code></pre><p>以上代码仅供参考，可能会超时。</p><h2 id="3-及时保存"><a href="#3-及时保存" class="headerlink" title="3.及时保存"></a>3.及时保存</h2><p>养成<code>ctrl+s</code>的习惯防止电脑忽然炸了，你也炸了</p><h2 id="4-数据试验"><a href="#4-数据试验" class="headerlink" title="4.数据试验"></a>4.数据试验</h2><p> (1).代码写好后，先把给的样例放进去试验。</p><p> (2).然后自己造数据，尽量造一些特例，如:边界的数据以及 0  1  -1等特殊数据，确保程序不error的情况下结果也要校对正确</p><p> (3). 观察每次出结果的时间，有没有比较难受的停顿，如果有，尽量优化的你代码，时间问题也很致命，尽量把数组开在main之外，最好是定长 例如 <code>static int array[20]</code></p><h2 id="5-注意一下"><a href="#5-注意一下" class="headerlink" title="5.注意一下"></a>5.注意一下</h2><ol><li><p>蓝桥杯和ACM不同，放入代码不会告诉你对错，其实是类似于答卷子，是可以修改的</p></li><li><p>前几道题是填空题，有时可以不用写代码解除，可以节省时间</p></li><li><p>填代码的填空题可以复制代码到编辑器，然后不停地去试，一般可以试出来</p></li><li><p>常考题型有限，最后一周可以针对性练习一下：</p><blockquote><p>搜索   枚举    模拟   递归   数学问题   动态规划  贪心  二分  DFS BFS 图   树</p></blockquote></li></ol><h2 id="6-常用头文件"><a href="#6-常用头文件" class="headerlink" title="6.常用头文件"></a>6.常用头文件</h2><p>使用头文件让你解题更快更舒服</p><pre><code class="c++">#include&lt;stdio.h&gt;    //输入输出#include&lt;stdlib.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;#include&lt;String.h&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;time.h&gt;</code></pre><h3 id="include-lt-stdlib-h-gt"><a href="#include-lt-stdlib-h-gt" class="headerlink" title="#include&lt;stdlib.h&gt;"></a>#include&lt;stdlib.h&gt;</h3><h4 id="bsearch-函数用法"><a href="#bsearch-函数用法" class="headerlink" title="bsearch()函数用法"></a>bsearch()函数用法</h4><pre><code class="c++">#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std; int cmpfunc(const void * a, const void * b){   return ( *(int*)a - *(int*)b );}int values[] = { 5, 20, 29, 32, 63 };int main (){   int *item;   int key = 3;   /* 使用 bsearch() 在数组中查找值 32 */   item = (int*) bsearch (&amp;key, values, 5, sizeof (int), cmpfunc);   if( item != NULL )    {      printf(&quot;Found item = %d\n&quot;, *item);   }   else    {      printf(&quot;Item = %d could not be found\n&quot;, key);   }   return(0);}</code></pre><h4 id="free-malloc-realloc"><a href="#free-malloc-realloc" class="headerlink" title="free()  malloc()   realloc()"></a>free()  malloc()   realloc()</h4><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(){   char *str;   /* 最初的内存分配 */   str = (char *) malloc(15);   strcpy(str, &quot;runoob&quot;);   printf(&quot;String = %s,  Address = %p\n&quot;, str, str);   /* 重新分配内存 */   str = (char *) realloc(str, 25);   strcat(str, &quot;.com&quot;);   printf(&quot;String = %s,  Address = %p\n&quot;, str, str);   /* 释放已分配的内存 */   free(str);   return(0);}</code></pre><h4 id="abs（）-取绝对值"><a href="#abs（）-取绝对值" class="headerlink" title="abs（） 取绝对值"></a>abs（） 取绝对值</h4><h3 id="include-lt-string-h-gt"><a href="#include-lt-string-h-gt" class="headerlink" title="#include&lt;string.h&gt;"></a>#include&lt;string.h&gt;</h3><p><a href="https://www.runoob.com/cprogramming/c-function-strcat.html" target="_blank" rel="noopener"> char *strcat(char *dest, const char *src)</a> </p><p>把 <em>src</em> 所指向的字符串追加到 <em>dest</em> 所指向的字符串的结尾。</p><p><a href="https://www.runoob.com/cprogramming/c-function-strcmp.html" target="_blank" rel="noopener"> int strcmp(const char *str1, const char *str2)</a> </p><p>把 <em>str1</em> 所指向的字符串和 <em>str2</em> 所指向的字符串进行比较。</p><p><a href="https://www.runoob.com/cprogramming/c-function-strcpy.html" target="_blank" rel="noopener"> char *strcpy(char *dest, const char *src)</a> </p><p>把 <em>src</em> 所指向的字符串复制到 <em>dest</em>。</p><h3 id="include-lt-math-h-gt"><a href="#include-lt-math-h-gt" class="headerlink" title="#include&lt;math.h&gt;"></a>#include&lt;math.h&gt;</h3><p><a href="https://www.runoob.com/cprogramming/c-function-pow.html" target="_blank" rel="noopener">double pow(double x, double y)</a><br>返回 x 的 y 次幂。</p><p><a href="https://www.runoob.com/cprogramming/c-function-sqrt.html" target="_blank" rel="noopener"> double sqrt(double x)</a></p><p> 返回 x 的平方根。</p><h3 id="include-lt-algorithm-gt"><a href="#include-lt-algorithm-gt" class="headerlink" title="#include&lt;algorithm&gt;"></a>#include&lt;algorithm&gt;</h3><p>sort 快速排序</p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;bool myfunction(int i,int j){    return(i&lt;j);}int main(){    int array[]={32,71,12,45,26,80,53,33};    vector&lt;int&gt; myarray (array,array+8);    sort(myarray.begin(),myarray.end(),myfunction);    int i=0;    for(i;i&lt;8;i++){        cout&lt;&lt;myarray[i]&lt;&lt;&quot; &quot;;    }} </code></pre><h2 id="7-玩一玩矩阵"><a href="#7-玩一玩矩阵" class="headerlink" title="7.玩一玩矩阵"></a>7.玩一玩矩阵</h2><h3 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h3><p><strong>题目</strong>：给出n×m的整数矩阵，请你把这个矩阵顺时针旋转90°后输出</p><p><strong>输入格式</strong>：</p><p>第一行输入两个整数n,m(1≤n,m≤200),用空格隔开。</p><p>接下来n行，每行输入m个整数，表示输入的矩阵，矩阵中元素都是int范围内的整数。</p><p><strong>输出格式：</strong></p><p>输入m行，每行n个空格隔开的整数，表示旋转后的矩阵。<strong>注意：</strong>每行末尾不能输出多余的空格</p><p><strong>样例输入：</strong></p><pre><code>3 4-1 3 6 37 7 9 110 3 4 6</code></pre><p>样例输出：</p><pre><code>10 7 -13 7 34 9 66 1 3</code></pre>]]></content>
    
    
    <categories>
      
      <category>蓝桥杯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DC小分子赛</title>
    <link href="/2020/03/12/DC%E5%B0%8F%E5%88%86%E5%AD%90%E8%B5%9B/"/>
    <url>/2020/03/12/DC%E5%B0%8F%E5%88%86%E5%AD%90%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="赛题"><a href="#赛题" class="headerlink" title="赛题"></a>赛题</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>根据小分子的属性特征，预测小分子在人体内清除率指标（即数据中的Label字段）。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><table><thead><tr><th>字段名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>ID</td><td>整型</td><td>样本编号</td></tr><tr><td>Molecule_max_phase</td><td>整型</td><td>分子的最长位相</td></tr><tr><td>Molecular weight</td><td>浮点型</td><td>分子量</td></tr><tr><td>RO5_violations</td><td>整型</td><td>违反新药5规则（RO5）的数量</td></tr><tr><td>AlogP</td><td>浮点型</td><td>由ACD软件计算化合物的脂分配系数（该数据来自ChemBL）</td></tr><tr><td>Features</td><td>向量</td><td>小分子的矢量化表示</td></tr><tr><td>Label</td><td>枚举/浮点型</td><td>单位时间内单位机体能将多少容积体液中的药物清除</td></tr></tbody></table><p><strong>注：本比赛id列不能算做有效特征。</strong></p><h2 id="评分标准"><a href="#评分标准" class="headerlink" title="评分标准"></a>评分标准</h2><p>评分算法</p><p>采用<strong>RMSE</strong>，参考代码如下：</p><pre><code>import numpy as npdef calc_rmse(y_pred, y_true):    return np.sqrt(((y_pred - y_true) ** 2).mean())y_pred = np.array([1, 2, 1, 2, 3])y_true = np.array([1, 1, 2, 2, 2])rmse = calc_rmse(y_pred, y_true)</code></pre><h2 id="分数记录"><a href="#分数记录" class="headerlink" title="分数记录"></a>分数记录</h2><table><thead><tr><th align="center">编号</th><th align="center">处理</th><th align="center">线下</th><th>线上</th></tr></thead><tbody><tr><td align="center">0323_1</td><td align="center">原始特征</td><td align="center">2.191179019653608</td><td></td></tr><tr><td align="center">0323_2</td><td align="center">features模</td><td align="center">2.196203627935492</td><td></td></tr><tr><td align="center">0323_3</td><td align="center">对Molecular_weight和AlogP进行exp</td><td align="center">2.1995688573340924</td><td></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td></td></tr></tbody></table><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="0323-1"><a href="#0323-1" class="headerlink" title="0323_1"></a>0323_1</h3><h4 id="进行的操作"><a href="#进行的操作" class="headerlink" title="进行的操作"></a>进行的操作</h4><p>无，即为原始特征</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="python">import numpy as npimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dimport pandas as pdimport lightgbm as lgbfrom tqdm import tqdmimport gcimport timefrom numpy import nanimport category_encoders as cefrom sklearn.model_selection import GridSearchCVfrom sklearn.model_selection import train_test_split,cross_val_scorepd.set_option(&#39;max_columns&#39;, None)pd.set_option(&#39;max_rows&#39;, None)pd.set_option(&#39;float_format&#39;, lambda x: &#39;%.6f&#39; % x)from tqdm import tqdmfrom sklearn.model_selection import GroupKFoldfrom sklearn.preprocessing import LabelEncoderfrom sklearn import feature_selectionfrom sklearn.model_selection import KFold, StratifiedKFoldfrom scipy import statsimport datetimeimport timefrom scipy.stats import entropy, kurtosisimport multiprocessingfrom gensim.models.word2vec import LineSentencefrom gensim.corpora import WikiCorpusfrom gensim.models import Word2Vecfrom sklearn.metrics import f1_score, classification_report, mean_squared_errorimport category_encoders as ceseed = 2020n_fold = 5#读入train=pd.read_csv(&#39;data/train_0312.csv&#39;)test=pd.read_csv(&#39;data/test_noLabel_0312.csv&#39;)#将Features 拆开for i in tqdm(range(6924)): train[&#39;Features&#39;][i]=eval(train[&#39;Features&#39;][i])for i in tqdm(range(1731)): test[&#39;Features&#39;][i]=eval(test[&#39;Features&#39;][i])test=pd.concat([test,pd.DataFrame(test[&#39;Features&#39;].tolist())],axis=1)train=pd.concat([train,pd.DataFrame(train[&#39;Features&#39;].tolist())],axis=1)#确定使用的特征ycol = &#39;Label&#39;feature_names = list(    filter(lambda x: x not in [ycol,&#39;ID&#39;,&#39;Features&#39;], train.columns))model = lgb.LGBMRegressor(num_leaves=70,                          max_depth=-1,                          learning_rate=0.01,                          n_estimators=10000,                          subsample=0.9,                          colsample_bytree=0.4,                          random_state=seed,                          metric=None                          )oof = []prediction = test[[&#39;ID&#39;]]prediction[&#39;Label&#39;] = 0df_importance_list = []#开始训练kfold = KFold(n_splits=n_fold, shuffle=False, random_state=seed)for fold_id, (trn_idx, val_idx) in enumerate(kfold.split(train[feature_names])):    X_train = train.iloc[trn_idx][feature_names]    Y_train = train.iloc[trn_idx][ycol]    X_val = train.iloc[val_idx][feature_names]    Y_val = train.iloc[val_idx][ycol]    print(&#39;\nFold_{} Training ================================\n&#39;.format(fold_id+1))    lgb_model = model.fit(X_train,                          Y_train,                          eval_names=[&#39;train&#39;, &#39;valid&#39;],                          eval_set=[(X_train, Y_train), (X_val, Y_val)],                          verbose=300,                          eval_metric=&#39;rmse&#39;,                          early_stopping_rounds=100                          )    pred_val = lgb_model.predict(X_val, num_iteration=lgb_model.best_iteration_)    df_oof = train.iloc[val_idx][[&#39;ID&#39;, ycol]].copy()    df_oof[&#39;pred&#39;] = pred_val    oof.append(df_oof)    pred_test = lgb_model.predict(test[feature_names], num_iteration=lgb_model.best_iteration_)    prediction[&#39;Label&#39;] += pred_test / n_fold    df_importance = pd.DataFrame({        &#39;column&#39;: feature_names,        &#39;importance&#39;: lgb_model.feature_importances_,    })    df_importance_list.append(df_importance)    del lgb_model, pred_val, pred_test, X_train, Y_train, X_val, Y_val    gc.collect()df_importance = pd.concat(df_importance_list)df_importance = df_importance.groupby([&#39;column&#39;])[&#39;importance&#39;].agg(    &#39;mean&#39;).sort_values(ascending=False).reset_index()df_importancedf_oof = pd.concat(oof)rmse = np.sqrt(mean_squared_error(df_oof[ycol], df_oof[&#39;pred&#39;]))print(&#39;rmse:&#39;, rmse)df_sub = pd.read_csv(&#39;data/submit_examp_0312.csv&#39;)sub = prediction.copy(deep=True)sub.to_csv(&#39;submission/{}.csv&#39;.format(rmse), index=False, encoding=&#39;utf-8&#39;)</code></pre><h4 id="特征重要性"><a href="#特征重要性" class="headerlink" title="特征重要性"></a>特征重要性</h4><table><thead><tr><th align="right">column</th><th align="right">importance</th><th></th></tr></thead><tbody><tr><td align="right">0</td><td align="right">AlogP</td><td>4111.000000</td></tr><tr><td align="right">1</td><td align="right">3153</td><td>3345.200000</td></tr><tr><td align="right">2</td><td align="right">3154</td><td>3232.400000</td></tr><tr><td align="right">3</td><td align="right">3152</td><td>3205.800000</td></tr><tr><td align="right">4</td><td align="right">3163</td><td>2966.400000</td></tr><tr><td align="right">5</td><td align="right">3166</td><td>2814.800000</td></tr><tr><td align="right">6</td><td align="right">3157</td><td>2793.400000</td></tr><tr><td align="right">7</td><td align="right">3156</td><td>2685.000000</td></tr><tr><td align="right">8</td><td align="right">Molecular weight</td><td>2589.400000</td></tr><tr><td align="right">9</td><td align="right">3159</td><td>2526.600000</td></tr><tr><td align="right">10</td><td align="right">3161</td><td>2197.000000</td></tr><tr><td align="right">11</td><td align="right">3155</td><td>2146.400000</td></tr><tr><td align="right">12</td><td align="right">3158</td><td>2116.600000</td></tr><tr><td align="right">13</td><td align="right">3151</td><td>1794.200000</td></tr><tr><td align="right">14</td><td align="right">11</td><td>1408.200000</td></tr><tr><td align="right">15</td><td align="right">8</td><td>1264.400000</td></tr><tr><td align="right">16</td><td align="right">3167</td><td>1181.400000</td></tr><tr><td align="right">17</td><td align="right">3162</td><td>1080.200000</td></tr><tr><td align="right">18</td><td align="right">6</td><td>1042.400000</td></tr><tr><td align="right">19</td><td align="right">16</td><td>903.800000</td></tr><tr><td align="right">20</td><td align="right">3164</td><td>887.400000</td></tr></tbody></table><p><strong>注：仅展示前20</strong></p><h3 id="0323-2"><a href="#0323-2" class="headerlink" title="0323_2"></a>0323_2</h3><h4 id="进行的操作-1"><a href="#进行的操作-1" class="headerlink" title="进行的操作"></a>进行的操作</h4><ol><li>features向量的模</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="python">train.fillna(method=&#39;ffill&#39;,inplace=True)test.fillna(method=&#39;ffill&#39;,inplace=True)train[&#39;mo&#39;]=0test[&#39;mo&#39;]=0a=lambda x:np.array(x)for i in range(6924):    train[&#39;mo&#39;][i]=np.linalg.norm(a(train[&#39;Features&#39;][i]))for i in range(1731):    test[&#39;mo&#39;][i]=np.linalg.norm(a(test[&#39;Features&#39;][i]))</code></pre><h4 id="特征重要性-1"><a href="#特征重要性-1" class="headerlink" title="特征重要性"></a>特征重要性</h4><table><thead><tr><th align="right">column</th><th align="right">importance</th><th></th></tr></thead><tbody><tr><td align="right">0</td><td align="right">AlogP</td><td>4235.400000</td></tr><tr><td align="right">1</td><td align="right">3153</td><td>3073.400000</td></tr><tr><td align="right">2</td><td align="right">3152</td><td>2963.800000</td></tr><tr><td align="right">3</td><td align="right">3154</td><td>2950.400000</td></tr><tr><td align="right">4</td><td align="right">3163</td><td>2847.400000</td></tr><tr><td align="right">5</td><td align="right">3166</td><td>2749.000000</td></tr><tr><td align="right">6</td><td align="right">mo</td><td>2670.200000</td></tr><tr><td align="right">7</td><td align="right">3157</td><td>2623.400000</td></tr><tr><td align="right">8</td><td align="right">3156</td><td>2566.800000</td></tr><tr><td align="right">9</td><td align="right">3159</td><td>2467.200000</td></tr><tr><td align="right">10</td><td align="right">Molecular weight</td><td>2212.200000</td></tr><tr><td align="right">11</td><td align="right">3158</td><td>1990.600000</td></tr><tr><td align="right">12</td><td align="right">3161</td><td>1979.400000</td></tr><tr><td align="right">13</td><td align="right">3155</td><td>1951.000000</td></tr><tr><td align="right">14</td><td align="right">3151</td><td>1489.800000</td></tr><tr><td align="right">15</td><td align="right">11</td><td>1315.200000</td></tr><tr><td align="right">16</td><td align="right">3167</td><td>1147.000000</td></tr><tr><td align="right">17</td><td align="right">8</td><td>1122.200000</td></tr><tr><td align="right">18</td><td align="right">6</td><td>968.400000</td></tr><tr><td align="right">19</td><td align="right">3162</td><td>931.400000</td></tr><tr><td align="right">20</td><td align="right">16</td><td>929.800000</td></tr></tbody></table><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为终端配置代理</title>
    <link href="/2020/03/12/%E4%B8%BA%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2020/03/12/%E4%B8%BA%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="为终端配置代理"><a href="#为终端配置代理" class="headerlink" title="为终端配置代理"></a>为终端配置代理</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><pre><code>set http_proxy=http://127.0.0.1:1080set https_proxy=http://127.0.0.1:1080# 1080是你shadowsocks设置的代理端口set http_proxy_user=userset http_proxy_pass=passset https_proxy_user=userset https_proxy_pass=pass# 恢复set http_proxy=set https_proxy=# Ubuntu 下命令为 export# export http_proxy=http://127.0.0.1:1080</code></pre><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><pre><code>export http_proxy=http://127.0.0.1:1080export https_proxy=http://127.0.0.1:1080</code></pre><blockquote><p>以上方式均为一次性，退出终端后失效</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>散装知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LightGBM+gridsearchcv</title>
    <link href="/2020/03/02/LightGBM-gridsearchcv/"/>
    <url>/2020/03/02/LightGBM-gridsearchcv/</url>
    
    <content type="html"><![CDATA[<h1 id="一-LightGBM核心参数"><a href="#一-LightGBM核心参数" class="headerlink" title="一 LightGBM核心参数"></a>一 LightGBM核心参数</h1><table><thead><tr><th>参数</th><th>中文含义</th><th>作用</th></tr></thead><tbody><tr><td>learning_rate</td><td>学习率，默认值0.1</td><td>控制模型迭代速度，越大模型迭代越快，但容易错过最优点；越小模型迭代越慢，容易找到最优点</td></tr><tr><td>num_iterations</td><td>迭代次数</td><td>控制迭代次数</td></tr><tr><td>max_depth</td><td>树的深度</td><td>设置树深度，深度越大越有可能过拟合</td></tr><tr><td>num_leaves</td><td>叶子节点数</td><td>调节树的复杂程度</td></tr><tr><td>min_data_in_leaf</td><td>叶子具有最小节点数</td><td>设置的较大可以避免生成一个过深的树，但有可能导致欠拟合</td></tr><tr><td>min_sum_hessian_in_leaf</td><td>结点分裂的最小海森值之和</td><td>也叫min_child_weight，使一个节点分裂的最小海森值之和</td></tr><tr><td>feature_fraction</td><td>特征子抽样</td><td>可以用来防止过拟合及提高训练速度</td></tr><tr><td>bagging_fraction</td><td>降采样</td><td>相当于subsample样本采样，可以使bagging更快的运行，同时也可以降拟合</td></tr><tr><td>bagging_freq</td><td>降采样频率</td><td>表示bagging的频率，0意味着没有使用bagging，k意味着每k轮迭代进行一次bagging</td></tr><tr><td>reg_alpha</td><td>L1正则化</td><td>降低过拟合</td></tr><tr><td>reg_lambda</td><td>L2正则化</td><td>降低过拟合</td></tr><tr><td>cat_smooth</td><td>类别平滑</td><td>设置每个类别需要有的最小个数</td></tr></tbody></table><h1 id="二gridsearchcv工作机制"><a href="#二gridsearchcv工作机制" class="headerlink" title="二gridsearchcv工作机制"></a>二gridsearchcv工作机制</h1><p>GridSearchCV=GridSearch+CV     即网格搜索和交叉验证</p><p>网格搜索，搜索的使参数，即在指定的参数范围内，按步长依次调整参数，利用调整的参数训练学习器，从所有的参数中找到在验证集上精度最高的参数，这其实是一个循环和比较的过程</p><p>GridSearchCV可以保证在指定的参数范围内找到精度最高的参数，但是这也是网格搜索的缺陷所在，它要求遍历所有可能参数的组合，在面对大数据集和多参数的情况下，非常耗时。</p><p>交叉验证的概念：</p><ul><li>将训练数据集划分为K份，K一般为10（也有取3~5）</li><li>依次取其中一份为验证集，其余为训练集训练分类器，测试分类器在验证集上的精度；</li><li>取K次实验的平均精度为该分类器的平均精度</li></ul><p>参数名称及含义如下：</p><table><thead><tr><th>参数名称</th><th align="left">含义</th></tr></thead><tbody><tr><td>estimator</td><td align="left">所使用的分类器</td></tr><tr><td>param_grid</td><td align="left">值为字典或者列表，即需要最优化的参数的取值</td></tr><tr><td>scoring</td><td align="left">准确度评价标准</td></tr><tr><td>cv</td><td align="left">交叉验证参数，没人None，使用三折交叉验证。指定fold数量，默认为3</td></tr><tr><td>refit</td><td align="left">默认为True，程序会以交叉验证数据集得到的最佳参数，重新对所有可用的训练集与开发集进行，作为最终用于性能评估的最佳模型参数。即在搜索参数结束后，用最佳参数结果再次fit一遍全部数据集</td></tr><tr><td>iid</td><td align="left">默认True，为True时，默认为各个样本fold概率分布一致，误差估计为所有样本之和，而非各个fold的平均</td></tr><tr><td>verbose</td><td align="left">日志冗长度，int：冗长度，0：不输出训练过程，1：偶尔输出   &gt;1：对每个子模型都输出</td></tr><tr><td>n_jobs</td><td align="left">并行数 int：个数   -1：跟CPU核数一致    默认值为1</td></tr><tr><td>pre_dispatch</td><td align="left">指定总共分发的并行任务数。当n_jobs大于1时，数据将在每个运行点进行复制，这颗呢我那个导致OOM，而设置pre_dispatch参数，则可以预先划分总共的job数量，使数据最多被赋值pre_dispatch次</td></tr></tbody></table><h2 id="三-使用gridsearchcv对lightgbm调参"><a href="#三-使用gridsearchcv对lightgbm调参" class="headerlink" title="三 使用gridsearchcv对lightgbm调参"></a>三 使用gridsearchcv对lightgbm调参</h2><p>对于基于决策树的模型，调参的方法都是大同小异。一般都需要如下步骤：</p><ol><li>首先选择较高的学习率  0.1附近    加快收敛速度</li><li>对决策树基本参数调参</li><li>正则化参数调参</li><li>最后降低学习率，这里是为了最后提高准确率</li></ol><p>我使用的默认参数如下：</p><pre><code>objective = &#39;binary&#39;,is_unbalance = True,metric = &#39;binary_logloss,auc&#39;,max_depth = 6,num_leaves = 40,learning_rate = 0.1,feature_fraction = 0.7,min_child_samples=21,min_child_weight=0.001,bagging_fraction = 1,bagging_freq = 2,reg_alpha = 0.001,reg_lambda = 8,cat_smooth = 0,num_iterations = 200,   </code></pre><p>开始时，需要把学习率和迭代次数调整到一个比较大的值。本人一般刚开始时设置learning_rate=0.1，num_iterations = 200。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据可视化</title>
    <link href="/2020/02/04/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <url>/2020/02/04/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Matploylib"><a href="#Matploylib" class="headerlink" title="Matploylib"></a>Matploylib</h1><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><pre><code></code></pre>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>决策树</title>
    <link href="/2020/01/27/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <url>/2020/01/27/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h3><table><thead><tr><th align="center">算法分类</th><th align="center">划分选择</th><th align="center">公式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ID3（Iterative Dichotomiser）</td><td align="center">信息增益</td><td align="center">Gain(D,a)=Ent(D)-Σ(|D^v|/|D|)*Ent(D^v)</td><td align="center">信息增益越大，由属性a划分而来的集合D的纯度越高，则优先将属性a作为该结点的划分依据</td></tr><tr><td align="center">C4.5</td><td align="center">增益率</td><td align="center">Gain_ratio(D,a)=Gain(D,a)/IV(a)</td><td align="center">信息增益除以属性a的固有值，找出增益率最高的，属性a可取数目越多，固有值越大。需要注意的是，增益率准则对可取数目较少的属性有所偏好。</td></tr><tr><td align="center">CART</td><td align="center">基尼指数</td><td align="center">Gini(D)=1-Σpk^2</td><td align="center">Gini(D)反映了从数据集D种随机挑两个样本，类别不一致的概率。所以基尼值越小，纯度越高。</td></tr></tbody></table><h3 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h3><h4 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h4><p>基于信息增益准则，选择属性对训练集进行划分，然后再通过验证集进行检验前后划分验证集精度（其实就是预测的正确率），如果提升则进行该次划分。</p><p><strong>优点：</strong>预剪枝使得决策树的很多分支都没有展开，降低过拟合的风险。</p><p><strong>缺点：</strong>有些分支的当前划分虽不能提升泛化性能、甚至可能导致泛化性能暂时下降，但在其基础上进行的后续划分却有可能导致性能显著提高，所以预剪枝决策树有欠拟合的风险。</p><h4 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h4><p>先生成一颗决策树，从最后的节点开始剪枝，如果有利于提高准确度就剪掉。</p><p>优点：保留了更多的分支，后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树</p><p>缺点：后剪枝过程是在生成完全决策树之后进行的，并且自底向上地对树中所有非叶结点进行逐一考察，因此其训练时间开销比未剪枝决策树和预剪枝决策树都要大得多。</p><h3 id="连续与缺失值"><a href="#连续与缺失值" class="headerlink" title="连续与缺失值"></a>连续与缺失值</h3><h4 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h4><p>确立划分点，划分点是能够使该属性信息增益最大的点。比如一个属性为密度，划分点为0.381，则可以&lt;0.381或者&gt;0.381作为种类的划分。<strong>需要注意的是，与离散属性不同，若当前结点划分属性为连续属性，该属性还可作为其后代结点的划分属性（即可以划分区间如&lt;0.381的子结点仍然可以划分出&gt;0.294）</strong></p><h4 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h4><p>若某样本属性a缺失，则在进行通过属性a划分时，将该样本同时划分到各个子结点中，只不过要赋予权重，权重为  各个子结点划分得到的样本数/该结点待划分的样本数</p><h3 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h3><p>在一个结点里有多个属性参与划分，在多变量决策树的学习过程中，不是为每个非叶结点寻找一个最优属性，而是试图建立一个合适的线性分类器。比如：</p><p>​                                                      -8.00×密度 - 0.044×含糖率&lt;=-0.313</p><p>​                                                        ↓是                                         ↓否</p><p>​                                                    好瓜                                         坏瓜</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><h3 id="调库"><a href="#调库" class="headerlink" title="调库"></a>调库</h3><h4 id="sklearn中DecisionTreeClassifier重要参数"><a href="#sklearn中DecisionTreeClassifier重要参数" class="headerlink" title="sklearn中DecisionTreeClassifier重要参数"></a>sklearn中DecisionTreeClassifier重要参数</h4><p>sklearn中决策树算法参数共有13个，如下：</p><p>class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, splitter=’best’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=None, random_state=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, class_weigh=None, presort=False)</p><p><strong>A.重要参数：criterion</strong></p><p>划分选择</p><p>(1) “entropy”，使用信息熵</p><p>(2) “gini”,使用基尼系数（默认）</p><blockquote><p>信息熵对不纯度更加敏感，对不纯度的惩罚最强。</p></blockquote><p><strong>B.重要参数：random_state&amp;splitte</strong></p><p>random_state用来设置分枝中的随机模式的参数，在高维度时随机性会表现更明显。</p><p>输入任意整数，会一直长出同一颗树，让模型稳定下来</p><p>splitter也是用来控制决策树中的随机选项的，有两种输入值，输入”best”，决策树在分枝时虽然随机，但是还是会优先选择更重要的特征进行分枝（重要性可以通过属性feature_importances_查看），输入“random”，决策树在分枝时会更加随机，树会因为含有更多的不必要信息而更深更大，并因这些不必要信息而降低对训练集的拟合。这也是防止过拟合的一种方式。当你预测到你的模型会过拟合，用这两个参数来帮助你降低树建成之后过拟合的可能性。当然，树一旦建成，我们依然是使用剪枝参数来<strong>防止过拟合</strong>。</p><p><strong>C.重要参数：剪枝参数</strong></p><p><strong>（1）max_depth</strong></p><p>限制树的最大深度，超过设定深度的树枝全部剪掉</p><p><strong>（2）min_samples_leaf</strong></p><p>min_samples_leaf（最少的节点）  每个分支下至少有该参数数量的节点，否则分枝就不会产生，或者朝着min_samples_leaf方向去发生。</p><p>一般搭配max_depth使用，在回归树中可以让模型变得更加平滑。太小引起过拟合。</p><blockquote><p>一般来说建议5开始使用。</p></blockquote><p><strong>(3)min_samples_split</strong></p><p>min_samples_split限定，一个节点必须要包含至少min_samples_split个训练样本，这个节点才允许被分枝，否则分枝就不会发生。</p><p><strong>(4)min_features</strong></p><p> max_features限制分枝时考虑的特征个数，超过限制个数的特征都会被舍弃</p><p><strong>(5)min_impurity_decrease</strong></p><p>min_impurity_decrease限制信息增益的大小，信息增益小于设定数值的分枝不会发生。</p><p><strong>D.确认最优的剪枝参数</strong></p><p>其实就是运用循环改变参数，确定出准确度最高的参数（也就是最优参数）</p><pre><code class="python">from sklearn import treefrom sklearn.datasets import load_winefrom sklearn.model_selection import train_test_splitwine = load_wine()xtrain,xtest,ytrain,ytest = train_test_split(wine.data,wine.target,test_size=0.3)clf=tree.DecisionTreeClassifier(criterion=&quot;entropy&quot;,random_state=30                                ,splitter=&quot;random&quot;,max_depth=3                                ,min_samples_leaf=10                                ,min_samples_split=70                                )clf=clf.fit(xtrain,ytrain)  #把训练数据集放入到分类器中，fit来寻找相应标签score = clf.score(xtest,ytest) #score是针对上面模型评估精确度print(score)import graphvizfeature_name = [&#39;酒精&#39;,&#39;苹果酸&#39;,&#39;灰&#39;,&#39;灰的碱性&#39;,&#39;镁&#39;,&#39;总酚&#39;,&#39;类黄酮&#39;,&#39;非黄烷类酚类&#39;,&#39;花青素&#39;,&#39;颜 色强度&#39;,&#39;色调&#39;,&#39;od280/od315稀释葡萄酒&#39;,&#39;脯氨酸&#39;]dot_data = tree.export_graphviz(clf                                , feature_names=feature_name                                , class_names=[&quot;琴酒&quot;, &quot;雪莉&quot;, &quot;贝尔摩德&quot;]                                , filled=True, rounded=True)graph = graphviz.Source(dot_data)graph.view()import matplotlib.pyplot as plttest = []ffor i in range(10):    clf=tree.DecisionTreeClassifier(max_depth=i+1                                    ,criterion=&quot;entropy&quot;,random_state=30                                    )    clf=clf.fit(xtrain,ytrain)    score_train = clf.score(xtrain, ytrain)    test.append(score)plt.plot(range(1,11),test,color=&#39;red&#39;,label=&#39;max_depth&#39;)plt.legend()plt.show()</code></pre><p><strong>E.目标权重参数</strong></p><p>(1)class_weight</p><p>完成样本标签平衡的参数。比如判断“信用卡持有人是否违约”的比例为（1％：99%）。这种分类状态，即便模型什么也不做，全部结果预测“否”，正确率也能有99%。因此我们要使用class_weight参数对样本标签进行一定的均衡，给少量的标签更多的权重，让模型更偏向少数类，向捕获少数类的方向建模。该参数默认None，此模式表示自动给与数据集中的所有标签相同的权重。</p><p>(2)min_weight_fraction_leaf</p><p>有了权重之后，样本量就不再是单纯地记录数目，而是受输入的权重影响了，因此这时候剪枝，就需要搭配min_ weight_fraction_leaf这个基于权重的剪枝参数来使用。另请注意，基于权重的剪枝参数（例如min_weight_ fraction_leaf）将比不知道样本权重的标准（比如min_samples_leaf）更少偏向主导类。如果样本是加权的，则使用基于权重的预修剪标准来更容易优化树结构，这确保叶节点至少包含样本权重的总和的一小部分。</p><p><strong>F.重要属性和接口</strong></p><p>最重要的属性是feature_importances_，能够查看各个特征对模型的重要性</p><pre><code>clf=tree.DecisionTreeClassifier()feature_importances=clf.feature_importances_# 输出feature就会得到各个特征对模型的重要性clf.fit(xtrain,ytrain)clf.score(xtest,ytest)clf.apply(xtest)  #返回clf.predict(xtest) #输出预测结果</code></pre><p>fit(训练模型)    score(准确性)   apply(输入测试集返回每个测试样本所在的叶子节点的索引)</p><p>predict(预测)</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NCCCU比赛</title>
    <link href="/2019/11/29/NCCCU%E6%AF%94%E8%B5%9B/"/>
    <url>/2019/11/29/NCCCU%E6%AF%94%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="数据挖掘标准流程"><a href="#数据挖掘标准流程" class="headerlink" title="数据挖掘标准流程"></a>数据挖掘标准流程</h1><p>了解课题背景和目标→了解评估标准→认识数据→分析与预处理→特征工程→基于模型测试与优化（数据决定了上限）→ 是否达到预期效果（否的话回到特征工程）→记录模型和结果</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ol><li>如何处理缺失值与重复值</li></ol><p>​    缺失值：删除，或填充</p><pre><code class="python">import pandas as pdimport numpy as npdf=pd.DateFrame([[1,np.nan,3],[4,5,np.nan],[7,8,9]])df.dropna() #默认以行删除df.dropna(axis=1,inplace=True) #注意inplace</code></pre><ol start="2"><li>特征缩放</li></ol><pre><code>min-max normalization(x-min)/(max-min)Mean normalizationx-average/max-minStandardizationx-average/std(标准差)from sklearn.preprocessing import StanderScalerstd=StanderScaler()</code></pre><ol start="3"><li><p>样本不均衡</p><p>某些品类不能被识别</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBootProject</title>
    <link href="/2019/10/22/SpringBootProject/"/>
    <url>/2019/10/22/SpringBootProject/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBootProject"><a href="#SpringBootProject" class="headerlink" title="SpringBootProject"></a>SpringBootProject</h1><h2 id="一-建表"><a href="#一-建表" class="headerlink" title="一  建表"></a>一  建表</h2><h2 id="二-mvn环境"><a href="#二-mvn环境" class="headerlink" title="二  mvn环境"></a>二  mvn环境</h2><ol><li><p>pom.xml  maven jar包</p></li><li><p>jdbc.properties 数据库连接方式</p></li><li><p>mybatis-config.xml </p></li><li><p>spring-dao.xml 将jdbc.properties mybatis.xml 加载进去  创建了datasource连接池</p><p>配置好了mybatis和数据库交互的方式</p></li><li><p>spring-service.xml  事务管理</p></li><li><p>spring-web.xml  定义dispatcher servlet  controller 行为</p></li></ol><h2 id="三-验证环境是否有问题"><a href="#三-验证环境是否有问题" class="headerlink" title="三 验证环境是否有问题"></a>三 验证环境是否有问题</h2>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2019/10/17/SpringBoot%E5%85%A5%E9%97%A8/"/>
    <url>/2019/10/17/SpringBoot%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot入门"><a href="#SpringBoot入门" class="headerlink" title="SpringBoot入门"></a>SpringBoot入门</h1><blockquote><p>SpringBoot入门→SpringBoot进阶→SpringBoot微信点餐系统→SpringCloud微服务实战</p></blockquote><h2 id="Spring-Boot应用开发流程"><a href="#Spring-Boot应用开发流程" class="headerlink" title="Spring Boot应用开发流程"></a>Spring Boot应用开发流程</h2><p>Spring应用开发流程：</p><p>配置环境  创建工程  构建目录结构   组件依赖管理   配置Web容器   </p><p>设置组件参数   业务开发  测试与构建  手动部署   运维与监控</p><p>SpringBoot开发流程：</p><p>配置环境（只需要jdk）     </p><p>Spring Initializr（一键生成Spring Boot 应用）     </p><p> 配置参数（可选）</p><p>业务开发</p><p>自动构建</p><p>自动部署</p><p>运维与监控</p><h1 id="Maven构建Spring-Boot应用"><a href="#Maven构建Spring-Boot应用" class="headerlink" title="Maven构建Spring Boot应用"></a>Maven构建Spring Boot应用</h1><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>安装JDK8以上</p></li><li><p>idea</p></li><li><p>SpringBoot 目录结构</p><table><thead><tr><th>/src/main</th><th>项目根目录</th></tr></thead><tbody><tr><td>/java</td><td>java源代码目录</td></tr><tr><td>/resources</td><td>资源目录</td></tr><tr><td>/resources/static</td><td>静态资源目录</td></tr><tr><td>/resources/templates</td><td>表示层页面目录</td></tr><tr><td>/resources/application.properties</td><td>Spring Boot配置文件</td></tr><tr><td>/test</td><td>测试文件目录</td></tr></tbody></table><h3 id="1-完善目录结构"><a href="#1-完善目录结构" class="headerlink" title="1. 完善目录结构"></a>1. 完善目录结构</h3><ul><li>/resources/static</li><li>/resources/templates</li><li>resources/application.properties</li></ul></li></ul><h3 id="2-添加组件依赖"><a href="#2-添加组件依赖" class="headerlink" title="2. 添加组件依赖"></a>2. 添加组件依赖</h3><pre><code class="xml">&lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><h3 id="3-创建Controller"><a href="#3-创建Controller" class="headerlink" title="3.创建Controller"></a>3.创建Controller</h3><p>java/com.myspringboot.controller/MyController.java</p><pre><code class="java">package com.myspringboot.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class MyController {    @RequestMapping(&quot;/out&quot;)   //out方法与url中的out绑定在一起    @ResponseBody   // 将return的内容原样输出到浏览器上    public String out(){        return &quot;success&quot;;    }}</code></pre><h3 id="4-创建MySpringBootApplication"><a href="#4-创建MySpringBootApplication" class="headerlink" title="4.创建MySpringBootApplication"></a>4.创建MySpringBootApplication</h3><p>创建java/com.springboot/MySpringBootApplication.java</p><pre><code class="java">package com.myspringboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;//说明这是一个SpringBoot应用的入口类@SpringBootApplicationpublic class MySpringBootApplication {    public static void main(String[] args) {        //启动SpringBoot应用        SpringApplication.run(MySpringBootApplication.class);    }}</code></pre><blockquote><p>打开localhost:8080/out 即可看到 success</p></blockquote><h1 id="Spring-Initializr构建SpringBoot应用"><a href="#Spring-Initializr构建SpringBoot应用" class="headerlink" title="Spring Initializr构建SpringBoot应用"></a>Spring Initializr构建SpringBoot应用</h1><blockquote><p> 自动生成配置</p></blockquote><h2 id="Spring-Boot-入门类"><a href="#Spring-Boot-入门类" class="headerlink" title="Spring Boot 入门类"></a>Spring Boot 入门类</h2><ul><li>入口类命令通常以*Application结尾</li><li>入口类上增加@SpringBootApplication注解</li><li>利用SpringApplication.run()方法启动应用</li></ul><pre><code class="java">package com.myspringboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class MyspringbootApplication {    public static void main(String[] args) {        SpringApplication.run(MyspringbootApplication.class, args);    }}</code></pre><h2 id="SprongBoot启动流程"><a href="#SprongBoot启动流程" class="headerlink" title="SprongBoot启动流程"></a>SprongBoot启动流程</h2><p>加载配置文件→application.properties</p><p>​    ↓</p><p>自动装配：</p><table><thead><tr><th>ArtifactId</th><th>描述</th></tr></thead><tbody><tr><td>spring-boot-starter-web</td><td>增加Web支持</td></tr><tr><td>spring-boot-starter-data-jpa</td><td>对JPA支持，继承Hibernate</td></tr><tr><td>spring-boot-starter-logging</td><td>增加logback日志的支持</td></tr><tr><td>spring-boot-starter-test</td><td>继承JUnit单元测试框架</td></tr></tbody></table><p>​    ↓</p><p>加载组件→ @Repository|@Service|@Controller|@Component|@Entity</p><p>​    ↓</p><p>应用初始化</p><h2 id="SpringBoot中的常用配置"><a href="#SpringBoot中的常用配置" class="headerlink" title="SpringBoot中的常用配置"></a>SpringBoot中的常用配置</h2><table><thead><tr><th>配置名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>server.port</td><td>8080</td><td>端口号</td></tr><tr><td>server.servlet.context-path</td><td>/</td><td>设置应用上下文</td></tr><tr><td>logging.file</td><td>无</td><td>日志文件输出路径</td></tr><tr><td>logging.level</td><td>info</td><td>最低日志输出级别</td></tr><tr><td>debug</td><td>false</td><td>开启/关闭调试模式</td></tr><tr><td>spring.datasource.*</td><td></td><td>与数据库相关的设置</td></tr><tr><td>…</td><td></td><td>…</td></tr></tbody></table><p>resources/application.properties</p><pre><code class="properties">server.port=80server.servlet.context-path=/myspringbootlogging.file=e:/myspringboot.log#1.debug 2.info 3.warn 4.error 5.fatallogging.level.root=info#debug更底层的运行细节debug=truespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=mjj666123</code></pre><h3 id="SpringBoot-支持两种配置文件"><a href="#SpringBoot-支持两种配置文件" class="headerlink" title="SpringBoot 支持两种配置文件"></a>SpringBoot 支持两种配置文件</h3><ul><li><p>properties</p></li><li><p>yml（推荐使用）</p><ul><li>标准格式：key:(空格)value</li><li>使用空格代表层级关系，以”：”结束</li></ul></li></ul><pre><code class="yml">debug: truelogging:  level: info  file: e:/myspringboot.logspring:  datasource:    driver-class-name: com.mysql.jdbc.driver    url: jdbc:mysql://localhost:3306/test    username: root    password: mjj666123</code></pre><h2 id="Spring-Boot自定义配置项"><a href="#Spring-Boot自定义配置项" class="headerlink" title="Spring Boot自定义配置项"></a>Spring Boot自定义配置项</h2><h2 id="环境配置文件（dev和prd）"><a href="#环境配置文件（dev和prd）" class="headerlink" title="环境配置文件（dev和prd）"></a>环境配置文件（dev和prd）</h2><ul><li><p>Spring Boot 可针对不同的环境提供不同的Profile文件。</p></li><li><p>Profile文件的默认命名格式为application-{env}.yml</p></li><li><p>使用spring.profiles.active选项来指定不同的profile</p></li></ul><p>两种环境 一个是开发时用的（dev）     另一个是上线时候用的（prd）</p><p>application-dev.yml</p><pre><code class="yml">debug: truelogging:  level:    root: info  file: e:/myspringboot.logspring:  datasource:    driver-class-name: com.mysql.jdbc.driver    url: jdbc:mysql://localhost:3306/test    username: root    password: mjj666123mall:  config:    name: 知识商城    description: 来这里收获知识    hot-sales: 20    show-advert: true</code></pre><p>application-prd.yml</p><pre><code class="yml">debug: falselogging:  level:    root: info  file: /local/user/app-prd.logspring:  datasource:    driver-class-name: com.mysql.jdbc.driver    url: jdbc:mysql://155.32.55.88:3307/prd    username: root    password: 3313@#!mall:  config:    name: 知识商城prd    description: 来这里收获知识    hot-sales: 20    show-advert: trueserver:  port: 80</code></pre><h2 id="打包与运行"><a href="#打包与运行" class="headerlink" title="打包与运行"></a>打包与运行</h2><ul><li>利用Maven的package命令，生成可独立运行的Jar包</li><li>利用java -jar xxx.jar 命令运行启动Spring Boot应用</li><li>Jar包可自动加载同目录的application配置文件(方便修改配置，灵活发布)</li></ul>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Node.js</title>
    <link href="/2019/09/24/Node-js/"/>
    <url>/2019/09/24/Node-js/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h2><h3 id="步骤一、引入required模块"><a href="#步骤一、引入required模块" class="headerlink" title="步骤一、引入required模块"></a>步骤一、引入required模块</h3><p>我们使用<strong>require</strong>指令来载入http模块，并将实例化的HTTP赋值给变量http，实例如下:</p><pre><code>var http = require(&quot;http&quot;);</code></pre><h3 id="步骤二、创建服务器"><a href="#步骤二、创建服务器" class="headerlink" title="步骤二、创建服务器"></a>步骤二、创建服务器</h3><p>接下来我们使用http.createServer()方法创建服务器，并使用listen方法绑定8888端口。 函数通过request, response参数来接收和响应数据。</p><p>实例如下，在你项目的根目录下创建一个叫server.js的文件，并写入以下代码：</p><pre><code class="js">var http = require(&#39;http&#39;);http.createServer(function (request, response) {    // 发送 HTTP 头部     // HTTP 状态值: 200 : OK    // 内容类型: text/plain    response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});    // 发送响应数据 &quot;Hello World&quot;    response.end(&#39;Hello World\n&#39;);}).listen(8888);// 终端打印如下信息console.log(&#39;Server running at http://127.0.0.1:8888/&#39;);</code></pre><p>以上代码我们完成了一个可以工作的HTTP服务器。</p><p>使用<strong>node</strong>命令执行以上的代码：</p><pre><code>node server.jsServer running at http://127.0.0.1:8888/</code></pre><p>​     <img src="https://atts.w3cschool.cn/attachments/image/20170627/1498557906641916.jpg" srcset="/img/loading.gif" alt="cmdrun">     </p><p>接下来，打开浏览器访问<a href="http://127.0.0.1:8888/，你会看到一个写着&quot;Hello" target="_blank" rel="noopener">http://127.0.0.1:8888/，你会看到一个写着&quot;Hello</a> World”的网页。</p><p>​     <img src="https://atts.w3cschool.cn/attachments/image/20170627/1498557954225656.jpg" srcset="/img/loading.gif" alt="nodejs-helloworld">     </p><p><strong>分析Node.js的HTTP服务器：</strong> </p><ul><li>第一行请求（require）Node.js自带的 http 模块，并且把它赋值给http变量。</li><li>接下来我们调用http模块提供的函数：createServer 。这个函数会返回 一个对象，这个对象有一个叫做listen的方法，这个方法有一个数值参数，指定这个HTTP服务器监听的端口号。</li></ul><h2 id="Node-js回调函数"><a href="#Node-js回调函数" class="headerlink" title="Node.js回调函数"></a>Node.js回调函数</h2><p>node.js异步编程的直接体现就是回调</p><p>回调函数在任务完成后就会被调用</p><pre><code class="js">var fs=require(&#39;fs&#39;);fs.readFile(&#39;input.txt&#39;,function(err,data){    if(err) return console.error(err);    console.log(data.toString());});console.log(&quot;程序执行结束！&quot;);</code></pre><p>输出结果：</p><p>程序执行结束！</p><p>“input.txt的内容”</p><h2 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a>Node.js 事件循环</h2><p>Node.js有多个内置的事件，我们可以通过引入events模块，并通过实例化EventEmitter类来绑定和监听事件，如下实例：</p><pre><code class="js">// 引入events模块var events = require(&#39;events&#39;);// 创建eventEmitter对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandlder = function connected(){    console.log(&#39;连接成功。&#39;);    // 触发 data_received 事件    eventEmitter.emit(&#39;data_received&#39;);}// 绑定connection事件处理程序eventEmitter.on(&#39;connection&#39;,connectHandler);// 使用匿名函数绑定 data_received 事件eventEmitter.on(&#39;data_received&#39;,function(){    console.log(&#39;数据接收成功。&#39;);});//触发 connection 事件eventEmitter.emit(&#39;connection&#39;);console.log(&#39;程序执行完毕。&#39;);</code></pre><p>执行以上代码可获得</p><pre><code>$ node main.js连接成功。数据接收成功。程序执行完毕。</code></pre><h3 id="Node应用程序是如何工作的？"><a href="#Node应用程序是如何工作的？" class="headerlink" title="Node应用程序是如何工作的？"></a>Node应用程序是如何工作的？</h3><p>创建一个 input.txt ,文件内容如下：</p><pre><code>马嘉骏要开心</code></pre><p>创建 main.js 文件，代码如下：</p><pre><code class="js">var fs = require(&quot;fs&quot;);fs.readFile(&#39;input.txt&#39;, function (err, data) {   if (err){      console.log(err.stack);      return;   }   console.log(data.toString());});console.log(&quot;程序执行完毕&quot;);</code></pre><p>结果如下：</p><pre><code>PS F:\360MoveData\Users\Lenovo\Desktop\HelloNode&gt; node call马嘉骏要开心程序执行结束</code></pre><p>假如删除input.txt</p><pre><code>PS F:\360MoveData\Users\Lenovo\Desktop\HelloNode&gt; node callfs.js:114    throw err;    ^Error: ENOENT: no such file or directory, open &#39;input.txt&#39;    at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10)    at Module.load (internal/modules/cjs/loader.js:653:32)    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)    at Function.Module._load (internal/modules/cjs/loader.js:585:3)    at Function.Module.runMain (internal/modules/cjs/loader.js:829:12)    at startup (internal/bootstrap/node.js:283:19)</code></pre><blockquote><p><strong>fs.readFile()：</strong></p><p>用于异步函数用于读取文件。</p><p>如果在读取文件过程中发生错误，错误err对象就会输出错误信息。</p><p>如果没有发生错误，readFile跳过err对象的输出，文件内容就通过回调函数输出</p></blockquote><h2 id="Node-js事件"><a href="#Node-js事件" class="headerlink" title="Node.js事件"></a>Node.js事件</h2><h2 id="Node-js文件处理"><a href="#Node-js文件处理" class="headerlink" title="Node.js文件处理"></a>Node.js文件处理</h2><blockquote><p>fs.unlink</p><p>删除文件</p><p>fs.mkdirSync(‘stuff’);</p><p>创建了一个stuff文件夹</p><p>fs.rmdirSync(‘stuff’);</p><p>删stuff  </p></blockquote><pre><code class="js">var fs = require(&#39;fs&#39;);fs.mkdir(&#39;stuff&#39;,function(){    fs.readFile(&#39;input1.txt&#39;,&#39;utf8&#39;,function(err,data){        fs.writeFile(&#39;stuff/writeMe.txt&#39;,data,function(){            console.log(&#39;copy successfully&#39;);        })    })});</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6</title>
    <link href="/2019/09/21/ES6/"/>
    <url>/2019/09/21/ES6/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ECMAScript6.0（简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><h2 id="ECMAScript和JavaScript的关系"><a href="#ECMAScript和JavaScript的关系" class="headerlink" title="ECMAScript和JavaScript的关系"></a>ECMAScript和JavaScript的关系</h2><p>ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。日常场合，这两个词可以互换。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="CMAScript-6-是什么？"><a href="#CMAScript-6-是什么？" class="headerlink" title="CMAScript 6 是什么？"></a>CMAScript 6 是什么？</h2><p>ECMAScript 6 也称为 ES6 和 ECMAScript 2015。</p><p>一些人把它称作 JavaScript 6。</p><p>本章介绍 ES6 中的一些新特性。</p><ul><li>JavaScript let</li><li>JavaScript const</li><li>幂 (**)</li><li>默认参数值</li><li>Array.find()</li><li>Array.findIndex()</li></ul><h2 id="对-ES6（ECMAScript-2015）的浏览器支持"><a href="#对-ES6（ECMAScript-2015）的浏览器支持" class="headerlink" title="对 ES6（ECMAScript 2015）的浏览器支持"></a>对 ES6（ECMAScript 2015）的浏览器支持</h2><p>Safari 10 和 Edge 14 是首先完全支持 ES6 的浏览器：</p><table><thead><tr><th>Chrome 58</th><th>Edge 14</th><th>Firefox 54</th><th>Safari 10</th><th>Opera 55</th></tr></thead><tbody><tr><td>Jan 2017</td><td>Aug 2016</td><td>Mar 2017</td><td>Jul 2016</td><td>Aug 2018</td></tr></tbody></table><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h2 id="JavaScript-let"><a href="#JavaScript-let" class="headerlink" title="JavaScript let"></a>JavaScript let</h2><ul><li>let语句允许使用块作用域声明变量</li></ul><pre><code class="js">var x = 10;// Here x is 10{   let x = 2;  // Here x is 2}// Here x is 10</code></pre><h2 id="JavaScript-const"><a href="#JavaScript-const" class="headerlink" title="JavaScript const"></a>JavaScript const</h2><p>const 语句允许您声明常量（具有常量值的 JavaScript 变量）。</p><p>常量类似于 let 变量，但不能更改值。</p><pre><code class="js">var x = 10;// Here x is 10{   const x = 2;  // Here x is 2}// Here x is 10</code></pre><h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><p>取幂运算符（**）将第一个操作数提升到第二个操作数的幂。</p><pre><code class="js">var x = 5;var z = x ** 2;          // 结果是 25</code></pre><p>x ** y 的结果与 Math.pow(x,y) 相同：</p><pre><code class="js">var x = 5;var z = Math.pow(x,2);   // 结果是 25</code></pre><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><p>ES6允许函数参数具有默认值</p><pre><code class="js">function myFunction(x,y=10){    //y is 10 if not passed or undefined    return x+y;}myFunction(5);</code></pre><h2 id="Array-find"><a href="#Array-find" class="headerlink" title="Array.find()"></a>Array.find()</h2><p>find()方法返回通过测试函数的第一个数组元素的值。</p><p>此例查找（返回）第一个大于18的元素（的值）：</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.find(myFunction);function myFunction(value, index, array) {  return value &gt; 18;}</code></pre><p>请注意次函数接受3个参数</p><ul><li>项目值</li><li>项目索引</li><li>数组本身</li></ul><h2 id="Array-findIndex"><a href="#Array-findIndex" class="headerlink" title="Array.findIndex()"></a>Array.findIndex()</h2><p>findIndex()方法返回通过测试函数的第一个数组元素的索引。</p><p>此例确定大于18的第一个元素的索引：</p><pre><code class="js">var numbers = [4, 9, 16, 25, 29];var first = numbers.findIndex(myFunction);function myFunction(value, index, array) {  return value &gt; 18;}//return 3</code></pre><p>请注意此函数接受 3 个参数：</p><ul><li>项目值</li><li>项目索引</li><li>数组本身</li></ul><h2 id="新的数字属性"><a href="#新的数字属性" class="headerlink" title="新的数字属性"></a>新的数字属性</h2><p>ES6 将以下属性添加到 Number 对象：</p><ul><li>EPSILON</li><li>MIN_SAFE_INTEGER</li><li>MAX_SAFE_INTEGER</li></ul><pre><code>var x = Number.EPSILON;</code></pre><p>x=2.220446049250313e-16</p><pre><code>var x = Number.MIN_SAFE_INTEGER;</code></pre><p>x=-9007199254740991</p><pre><code>var x = Number.MAX_SAFE_INTEGER;</code></pre><p>x=9007199254740991</p><h2 id="新的数字方法"><a href="#新的数字方法" class="headerlink" title="新的数字方法"></a>新的数字方法</h2><p>ES6为Number对象添加了2个新方法：</p><ul><li>Number,isInteger()</li><li>Number.isSafeInteger()</li></ul><h2 id="Number-isInteger-方法"><a href="#Number-isInteger-方法" class="headerlink" title="Number.isInteger() 方法"></a>Number.isInteger() 方法</h2><p>如果参数是整数，则 Number.isInteger() 方法返回 true。</p><pre><code>Number.isInteger(10);        // 返回 trueNumber.isInteger(10.5);      // 返回 false</code></pre><h2 id="Number-isSafeInteger-方法"><a href="#Number-isSafeInteger-方法" class="headerlink" title="Number.isSafeInteger() 方法"></a>Number.isSafeInteger() 方法</h2><p>安全整数是可以精确表示为双精度数的整数。</p><p>如果参数是安全整数，则 Number.isSafeInteger() 方法返回 true。</p><pre><code>Number.isSafeInteger(10);    // 返回 trueNumber.isSafeInteger(12345678901234567890);  // 返回 false</code></pre><p>安全整数指的是从 -(253 - 1) 到 +(253 - 1) 的所有整数。</p><p>这是安全的：9007199254740991。这是不安全的：9007199254740992。</p><h2 id="新的全局方法"><a href="#新的全局方法" class="headerlink" title="新的全局方法"></a>新的全局方法</h2><p>ES6 还增加了 2 个新的全局数字方法：</p><ul><li>isFinite()</li><li>isNaN()</li></ul><h2 id="isFinite-方法"><a href="#isFinite-方法" class="headerlink" title="isFinite() 方法"></a>isFinite() 方法</h2><p>如果参数为 Infinity 或 NaN，则全局 isFinite() 方法返回 false。</p><p>否则返回 true：</p><pre><code>isFinite(10/0);       // 返回 falseisFinite(10/1);       // 返回 true</code></pre><h2 id="isNaN-方法"><a href="#isNaN-方法" class="headerlink" title="isNaN() 方法"></a>isNaN() 方法</h2><p>如果参数是 NaN，则全局 isNaN() 方法返回 true。否则返回 false：</p><pre><code>isNaN(&quot;Hello&quot;);       // 返回 true</code></pre><h2 id="箭头函数（Arrow-Function）"><a href="#箭头函数（Arrow-Function）" class="headerlink" title="箭头函数（Arrow Function）"></a>箭头函数（Arrow Function）</h2><p>箭头函数允许使用简短的语法来编写函数表达式。</p><p>您不需要 function 关键字、return 关键字以及<em>花括号</em>。</p><pre><code>// ES5var x = function(x, y) {   return x * y;}// ES6const x = (x, y) =&gt; x * y;</code></pre><p>箭头功能没有自己的 this。它们不适合定义<em>对象方法</em>。</p><p>箭头功能未被提升。它们必须在使用<em>前</em>进行定义。</p><p>使用 const 比使用 var 更安全，因为函数表达式始终是常量值。</p><p>如果函数是单个语句，则只能省略 return 关键字和花括号。因此，保留它们可能是一个好习惯：</p><pre><code>const x = (x, y) =&gt; { return x * y };</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cookie&amp;Session</title>
    <link href="/2019/09/16/Cookie&amp;Session/"/>
    <url>/2019/09/16/Cookie&amp;Session/</url>
    
    <content type="html"><![CDATA[<h1 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie&amp;Session"></a>Cookie&amp;Session</h1><h2 id="Cookie（客户端）"><a href="#Cookie（客户端）" class="headerlink" title="Cookie（客户端）"></a>Cookie（客户端）</h2><ul><li>Cookie(小甜饼)   是浏览器保存在本地的文本内容</li><li>Cookie常用于保存登录状态、用户资料等小文本</li><li>Cookie具有时效性，Cookie内容会伴随请求发送给Tomcat</li></ul><p><strong>Servlet/LoginServlet</strong></p><pre><code class="java">package Servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/login&quot;)public class LoginServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doPost(req, resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println(&quot;用户登录成功&quot;);        Cookie cookie=new Cookie(&quot;user&quot;,&quot;admin&quot;);        cookie.setMaxAge(60*60*24*7);        //60s  60分钟  24小时  7天        resp.addCookie(cookie);        resp.getWriter().println(&quot;login success&quot;);    }}</code></pre><p><strong>Servlet/indexServlet</strong></p><pre><code class="java">package Servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/index&quot;)public class indexServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doPost(req,resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //req.getCookies()用户获取所有的Cookie        Cookie[] cs=req.getCookies();        if(cs==null){            System.out.println(&quot;not login&quot;);            return;        }        String user=null;        for(Cookie c:cs){            System.out.println(c.getName()+&quot;:&quot;+c.getValue());            if(c.getName().equals(&quot;user&quot;)){                user=c.getValue();                break;            }        }        if(user==null){            resp.getWriter().println(&quot;user not login&quot;);        }else{            resp.getWriter().println(&quot;user:&quot;+user);        }    }}</code></pre><h3 id="Cookie的时效性"><a href="#Cookie的时效性" class="headerlink" title="Cookie的时效性"></a>Cookie的时效性</h3><ul><li>不设置：即为窗口时效性</li></ul><h2 id="Session-用户会话（存在服务器端）"><a href="#Session-用户会话（存在服务器端）" class="headerlink" title="Session-用户会话（存在服务器端）"></a>Session-用户会话（存在服务器端）</h2><ul><li><p>Session(用户会话)用于保存与”浏览器窗口”对应的数据</p></li><li><p>Session的数据存储在Tomcat服务器的内存中，具有时效性</p></li><li><p>Session通过浏览器Cookie的SessionId提取用户数据</p></li></ul><p><strong>Servlet/SessionServlet</strong></p><pre><code class="java">package Servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;@WebServlet(&quot;/Slogin&quot;)public class SessionServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {         this.doPost(req, resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        System.out.println(&quot;登录成功&quot;);        //获取到用户会话Session对象        HttpSession session=req.getSession();        String sessionId=session.getId();        System.out.println(sessionId);        session.setAttribute(&quot;name&quot;,&quot;张三&quot;);        req.getRequestDispatcher(&quot;Sindex&quot;).forward(req,resp);    }}</code></pre><p><strong>Servlet/Sessionindex</strong></p><pre><code class="java">package Servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;@WebServlet(&quot;/Sindex&quot;)public class Sessionindex extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doPost(req, resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        HttpSession session=req.getSession();        String name= (String) session.getAttribute(&quot;name&quot;);        resp.setContentType(&quot;text/html;charset=utf-8&quot;);        resp.getWriter().println(&quot;这是首页，当前用户：&quot;+name);    }}</code></pre><h2 id="Session的原理"><a href="#Session的原理" class="headerlink" title="Session的原理"></a>Session的原理</h2><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><ul><li>ServletContext(Servlet上下文对象)，是Web应用全局对象</li><li>一个Web应用只会创建一个ServletContext对象</li><li>ServletContext随着Web应用启动而自动创建</li></ul>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2019/09/14/Spring/"/>
    <url>/2019/09/14/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><ul><li>Spring的概述</li><li>Spring的入门</li></ul><h2 id="什么是spring框架？"><a href="#什么是spring框架？" class="headerlink" title="什么是spring框架？"></a>什么是spring框架？</h2><ul><li>Spring是一个开源框架</li><li>Spring为简化企业级应用开发而生。使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能</li><li>Spring使javaSE/JavaEE的一站式框架</li></ul><p>Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p><p>◆目的：解决企业应用开发的复杂性</p><p>◆功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</p><p>◆范围：任何Java应用</p><p>Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。</p><h3 id="Spring的优点"><a href="#Spring的优点" class="headerlink" title="Spring的优点"></a>Spring的优点</h3><ul><li>方便解耦，简化开发<ul><li>spring就是个大工厂，将所有对象创建和依赖关系维护，交给Spring管理</li></ul></li><li>AOP编程的支持<ul><li>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能</li></ul></li><li>声明式事务的支持<ul><li>只需要通过配置就可以完成对事务的管理，而且无需手动编程</li></ul></li><li>方便程序测试<ul><li>Spring对junit4支持，可以用过注解方便的测试Spring程序</li></ul></li><li>方便集成各种优秀框架<ul><li>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibertnate、MyBatis等）的直接支持</li></ul></li><li>降低JavaEE API的使用难度<ul><li>Spring对JavaEE开发中非常难用的一些API（JDBC、Javamail、远程调用等），都提供了封装，使这些API应用难度大大降低</li></ul></li></ul><h3 id="Spring-IOC的底层原理实现"><a href="#Spring-IOC的底层原理实现" class="headerlink" title="Spring IOC的底层原理实现"></a>Spring IOC的底层原理实现</h3><p>传统方式的开发</p><p>UserService us=new UserService();</p><p>​                    ↓  面向接口编程</p><p>UserService us=new UserSerivceImpl();</p><p>​                    ↓  ocp原则：open-close 原则,对程序拓展是open的，对修改程序代码是close</p><p>​                    ↓                    尽量做到不修改程序的源码，实现对程序的扩展</p><p>​            工厂模式</p><p>工厂类创建 示例对象</p><pre><code class="java">class FactoryBean{    public static UserService getUs(){        return new UserServiceImpl();    }}UserService us=FactoryBean.getUs();</code></pre><p>工厂+反射+配置文件</p><pre><code class="xml">&lt;bean id=&quot;us&quot; class=&quot;com.imooc.UserServiceImpl&quot;/&gt;</code></pre><pre><code class="java">class FactoryBean{    public static Object getBean(String id){        ...        反射    }}</code></pre><h3 id="Spring-IOC的快速入门案例"><a href="#Spring-IOC的快速入门案例" class="headerlink" title="Spring IOC的快速入门案例"></a>Spring IOC的快速入门案例</h3><ul><li><p>下载Spring开发包</p><p><a href="https://repo.spring.io/libs-release-local/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/libs-release-local/org/springframework/spring/</a></p></li><li><p>复制Spring开发jar包到工程</p></li><li><p>理解IOC控制反转和DI依赖注入</p></li><li><p>编写Spring核心配置文件</p></li><li><p>在程序中读取Spring配置文件，通过Spring框架获得Bean，完成相应操作</p></li></ul><ol><li><p>创建Maven工程</p><p>pom.xml</p><p>spring相关依赖</p><p>spring-core/spring-context/spring-beans/spring-logging</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;sipc&lt;/groupId&gt;  &lt;artifactId&gt;food&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;food Maven Webapp&lt;/name&gt;  &lt;!-- FIXME change it to the project&#39;s website --&gt;  &lt;url&gt;http://www.example.com&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.11&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;      &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-logging&lt;/groupId&gt;      &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;      &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;log4j&lt;/groupId&gt;      &lt;artifactId&gt;log4j&lt;/artifactId&gt;      &lt;version&gt;1.2.17&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;finalName&gt;food&lt;/finalName&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.1.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.8.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.22.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre></li></ol><ol start="2"><li><p>创建applicationContext.xml</p></li><li><p>创建接口</p></li><li><p>继承接口</p></li><li><p>SpringDemo1</p><pre><code class="java">package ioc.demo1;</code></pre></li></ol><p>   import org.junit.Test;<br>   import org.springframework.context.ApplicationContext;<br>   import org.springframework.context.support.ClassPathXmlApplicationContext;</p><p>   public class SpringDemo1 {<br>       @Test<br>       public void demo1(){<br>           UserService userService=new UserServiceImpl();<br>           userService.sayHello();<br>       }<br>       @Test<br>   //    spring的方式实现<br>       public void demo2(){<br>           //创建Spring的工厂<br>           ApplicationContext applicationContext=new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>           //通过工厂获得类<br>           UserService userService=(UserService) applicationContext.getBean(“userService”);</p><pre><code>       userService.sayHello();   }</code></pre><p>   }</p><pre><code>### IOC和DI的概念- IOC  Inverse of Control 反转控制的概念，就是将原本在程序中手动创建UserService对象的控制权，交由  Spring框架处理- 简单说，就是创建UserService对象控制权被反转到了Spring框架- DI Dependency Injection 依赖注入的概念，就是在Spring创建这个对象的过程中，  将这个对象所依赖的属性注入进去```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--UserService的创建权交给了Spring--&gt;    &lt;bean id=&quot;userService&quot; class=&quot;ioc.demo1.UserServiceImpl&quot;&gt;        &lt;!--控制反转--&gt;        &lt;!--设置属性--&gt;        &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt;        &lt;!--依赖注入--&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id="Spring-Bean管理"><a href="#Spring-Bean管理" class="headerlink" title="Spring Bean管理"></a>Spring Bean管理</h2><h3 id="三种实例化Bean的方式"><a href="#三种实例化Bean的方式" class="headerlink" title="三种实例化Bean的方式"></a>三种实例化Bean的方式</h3><ul><li><p>使用类构造器实例化（默认无参数）</p><ol><li>创建java/demo2/Bean1</li></ol><pre><code class="java">package demo2;//实例化的三种方式：采用无参数的构造方法的参数public class Bean1 {    public Bean1(){    }}</code></pre><ol start="2"><li>配置spring config applicationContext.xml</li></ol><pre><code class="xml">&lt;bean id=&quot;bean1&quot; class=&quot;demo2.Bean1&quot;/&gt;</code></pre><pre><code>3. SpringDemo2中（测试）</code></pre><pre><code class="java">package demo2;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringDemo2 {    @Test    public void demo1(){        //创建工厂        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //通过工厂获得类的实例        Bean1 bean1= (Bean1) applicationContext.getBean(&quot;bean1&quot;);    }}</code></pre></li></ul><ul><li><p>使用静态工厂方法实例化（简单工厂模式）</p><ol><li>创建java/demo2/Bean2</li></ol><pre><code class="java">package demo2;//静态工厂实例化方式public class Bean2 {}</code></pre><ol start="2"><li>创建demo2/Bean2Factory</li></ol><pre><code class="java">package demo2;public class Bean2Factory {    //第二种：Bean2的静态工厂    public static Bean2 createBean2(){        System.out.println(&quot;Bean2Factory的方法已经执行了&quot;);        return new Bean2();    }}</code></pre></li></ul><pre><code>  3. applicationContext.xml     ```xml      &lt;bean id=&quot;bean2&quot; class=&quot;demo2.Bean2Factory&quot; factory-method=&quot;createBean2&quot;/&gt;     ```  4. SpringDemo2中（包含bean3）  ```java  package demo2;  import org.junit.Test;  import org.springframework.context.ApplicationContext;  import org.springframework.context.support.ClassPathXmlApplicationContext;  public class SpringDemo2 {      @Test      public void demo1(){          //创建工厂          ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);          //通过工厂获得类的实例          Bean1 bean1= (Bean1) applicationContext.getBean(&quot;bean1&quot;);      }      public void demo2(){          //创建工厂          ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);          //通过工厂获得类的实例          Bean2 bean2= (Bean2) applicationContext.getBean(&quot;bean2&quot;);      }      public void demo3(){          //创建工厂          ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);          //通过工厂获得类的实例          Bean3 bean3= (Bean3) applicationContext.getBean(&quot;bean3&quot;);      }  }</code></pre><ul><li>使用实例工厂方法实例化（工厂方法模式）</li></ul><ol><li>java/demo2/Bean3</li></ol><pre><code class="java">package demo2;//第三种：实例工厂实例化的方式public class Bean3 {}</code></pre><ol start="2"><li>demo2/Bean3Factory</li></ol><pre><code class="java">package demo2;public class Bean3Factory {    public Bean3 createBean3(){        System.out.println(&quot;Bean3Factory被执行了&quot;);        return new Bean3();    }}</code></pre><ol start="3"><li>applicationContext.xml</li></ol><pre><code class="xml">&lt;bean id=&quot;bean3Factory&quot; class=&quot;demo2.Bean3Factory&quot;/&gt;&lt;bean id=&quot;bean3&quot; factory-bean=&quot;bean3Factory&quot; factory-method=&quot;createBean3&quot;/&gt;</code></pre><ol start="4"><li>SpringDemo2</li></ol><pre><code class="java">package demo2;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringDemo2 {    @Test    public void demo1(){        //创建工厂        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //通过工厂获得类的实例        Bean1 bean1= (Bean1) applicationContext.getBean(&quot;bean1&quot;);    }    public void demo2(){        //创建工厂        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //通过工厂获得类的实例        Bean2 bean2= (Bean2) applicationContext.getBean(&quot;bean2&quot;);    }    public void demo3(){        //创建工厂        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //通过工厂获得类的实例        Bean3 bean3= (Bean3) applicationContext.getBean(&quot;bean3&quot;);    }}</code></pre><h3 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h3><ul><li>id和name<ul><li>一般情况下，装配一个Bean时，通过指定一个id属性作为Bean的名称</li><li>id 属性在IOC容器中必须是唯一的</li><li>如果Bean的名称中含有特殊字符，就需要使用name属性</li></ul></li><li>class<ul><li>class用于设置一个类的完全路径名称，主要作用是IOC容器生成类的实例</li></ul></li></ul><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>在SpringIOC容器中仅存在一个Bean实例，Bean以单实例的方式存在</td></tr><tr><td>prototype</td><td>每次调用getBean()时都会返回一个新的实例</td></tr><tr><td>request</td><td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</td></tr><tr><td>session</td><td>同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean，该作用域仅适用于WebApplicationContext环境</td></tr></tbody></table><p><strong>applicationContext.xml</strong></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--Bean的作用范围--&gt;    &lt;bean id=&quot;person&quot; class=&quot;com.majiajun.demo3.Person&quot; scope=&quot;prototype&quot;/&gt;&lt;/beans&gt;</code></pre><p><strong>demo3/Person</strong></p><pre><code class="java">package com.majiajun.demo3;public class Person {}</code></pre><p><strong>demo3/SpringDemo3</strong></p><pre><code class="java">package com.majiajun.demo3;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/*Bean作用范围的测试*/public class SpringDemo3 {    @Test    public void demo1(){        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        Person person= (Person) applicationContext.getBean(&quot;person&quot;);        Person person1=(Person) applicationContext.getBean(&quot;person&quot;);        System.out.println(person);        System.out.println(person1);    }}</code></pre><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><pre><code class="xml">&lt;bean id=&quot;man&quot; class=&quot;demo3.Man&quot; init-method=&quot;setup&quot; destroy-method=&quot;teardown&quot;&gt;&lt;/bean&gt;</code></pre><h3 id="Bean的生命周期的完整过程"><a href="#Bean的生命周期的完整过程" class="headerlink" title="Bean的生命周期的完整过程"></a>Bean的生命周期的完整过程</h3><ol><li><p>instantiate bean对象实例化</p><pre><code class="java">public class Man(){    public Man(){        System.out.println(&quot;第一步：对象的实例化&quot;);    }}</code></pre></li><li><p>poprlate properties封装属性</p><pre><code class="java">public class Man{    private String name;    public void setName(String name) {        System.out.println(&quot;第二步：设置属性&quot;);        this.name = name;    }</code></pre></li><li><p>如果Bean实现BeanNameAware执行setBeanName</p></li><li><p>如果Bean实现BeanFactoryAware或者ApplicationContextAware设置工厂 setBeanFactory或者上下文对象setApplicationContext</p><pre><code class="java">public class Man implements BeanNameAware, ApplicationContextAware {    private String name;    public void setName(String name) {        System.out.println(&quot;设置属性&quot;);        this.name = name;    }    public Man(){        System.out.println(&quot;Man被实例化&quot;);    }    public void setup(){        System.out.println(&quot;Man被初始化&quot;);    }    public void teardown(){        System.out.println(&quot;Man被销毁了&quot;);    }    @Override    public void setBeanName(String s) {        System.out.println(&quot;第三步：设置Bean的&quot;);    }    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        System.out.println(&quot;第四步：了解工厂的信息&quot;);    }}</code></pre></li><li><p>如果存在类实现BeanPostProcessor（后处理Bean），执行postProcessBeforeInitialization</p><pre><code class="java">package com.majiajun.demo3;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanProcessor implements BeanPostProcessor {    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        System.out.println(&quot;第五步：初始化前方法&quot;);        return bean;    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        System.out.println(&quot;第八步：初始化后方法&quot;);        return bean;    }}</code></pre></li><li><p>如果Bean实现InitializingBean执行afterPropertiesSet</p><pre><code class="java">package com.majiajun.demo3;import org.springframework.beans.BeansException;import org.springframework.beans.factory.BeanNameAware;import org.springframework.beans.factory.InitializingBean;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class Man implements BeanNameAware, ApplicationContextAware, InitializingBean {    private String name;    public void setName(String name) {        System.out.println(&quot;设置属性&quot;);        this.name = name;    }    public Man(){        System.out.println(&quot;Man被实例化&quot;);    }    public void setup(){        System.out.println(&quot;Man被初始化&quot;);    }    public void teardown(){        System.out.println(&quot;Man被销毁了&quot;);    }    @Override    public void setBeanName(String s) {        System.out.println(&quot;第三步：设置Bean的&quot;);    }    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        System.out.println(&quot;第四步：了解工厂的信息&quot;);    }    @Override    public void afterPropertiesSet() throws Exception {        System.out.println(&quot;第六步：属性设置后&quot;);    }}</code></pre></li><li><p>调用<bean init-method="init">指定初始化方法init</bean></p></li><li><p>如果存在类实现BeanPostProcessor（后处理Bean），执行postProcessAfterInitialization</p></li><li><p>执行业务处理（自己定义的方法），如下</p><pre><code class="java">public class Man{     public void run(){        System.out.println(&quot;第九步：执行业务方法&quot;);    }}</code></pre></li><li><p>如果Bean实现DisposableBean执行destory</p><pre><code class="java">public class Man implements DisposableBean{    public void destory()throws Exception{        System.out.println(&quot;第十步：执行Spring的销毁方法&quot;);    }}</code></pre></li><li><p>调用<bean destory-method="customerDestroy">指定销毁方法customerDestory</bean></p></li></ol><h4 id="Spring容器中Bean的生命周期"><a href="#Spring容器中Bean的生命周期" class="headerlink" title="Spring容器中Bean的生命周期"></a>Spring容器中Bean的生命周期</h4><ul><li>演示如何增强一个类中的方法</li></ul><h3 id="Spring的属性注入"><a href="#Spring的属性注入" class="headerlink" title="Spring的属性注入"></a>Spring的属性注入</h3><ul><li><p>对于类成员变量，注入方式有三种</p><ul><li>构造函数注入<ul><li>通过构造方法注入Bean的属性值或依赖的对象，它保证了Bean实例在实例化后就可以使用</li></ul></li><li>属性settrt方法注入  </li><li>接口注入</li></ul></li><li><p>Spring支持前两种</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重定向和请求转发</title>
    <link href="/2019/09/01/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91/"/>
    <url>/2019/09/01/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="javaweb中重定向（response-sendRedirect-url-）和请求转发-request-getRequestDispatcher-url-forward-req-resop-的区别"><a href="#javaweb中重定向（response-sendRedirect-url-）和请求转发-request-getRequestDispatcher-url-forward-req-resop-的区别" class="headerlink" title="javaweb中重定向（response.sendRedirect(url)）和请求转发(request.getRequestDispatcher(url).forward(req,resop))的区别"></a>javaweb中重定向（response.sendRedirect(url)）和请求转发(request.getRequestDispatcher(url).forward(req,resop))的区别</h3><p>![image](重定向和请求转发\1003414-20170724194124918-1066381530 (1).png)</p><p>​    可以看出，重定向时，是服务器向游览器重新发送了一个response命令,让游览器再次向url2发送请求，以获取url2的资源</p><p>​    而请求转发时，类似于是服务器自己向自己发了一个跳转，然后将结果直接给游览器，这也是问什么游览器会不改变url地址。下面是具体总结他们的区别</p><ol><li><p>response.sendRedirect(url) 服务器将新url发送给浏览器，浏览器再根据新url请求</p><p>request.getRequestDispatcher(url).forward(request,response);请求转发到指定url（服务器内部跳转url然后将结果发给浏览器）</p></li><li><p>response.sendRedirect(url)—客户端跳转</p><p>Request.getRequestDispatcher(url).forward(request,response)—服务器跳转</p></li><li><p>跳转到指定url地址后，上个页面的请求会结束，request对象会消亡，数据会消亡</p><p>内部跳转，request对象一直存在</p></li><li><p>网址会改变</p><p>以浏览器角度来看，他只是发送一个request然后收到一个response，所以url不变</p></li><li><p>传参数需要在url后加参数</p><p>传参数可以操作request对象方法setAttribute(“name”,value)</p></li><li><p>可以定位到任意的网址</p><p>只能定位到服务器资源</p></li><li><p>可以重定向有frame得到jsp文件</p><p>不可以重定向有frame的jsp文件，可以重定向到有frame的html文件，只有再客户端没有输出时才可以调用forward方法，如果当前页面缓冲区不是空的，那么该句可能不起作用，由于这种提交不会改变url地址，刷新会重复提交</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次MyBatis试手项目</title>
    <link href="/2019/08/07/%E8%AE%B0%E4%B8%80%E6%AC%A1MyBatis%E8%AF%95%E6%89%8B%E9%A1%B9%E7%9B%AE/"/>
    <url>/2019/08/07/%E8%AE%B0%E4%B8%80%E6%AC%A1MyBatis%E8%AF%95%E6%89%8B%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次MyBatis试手项目"><a href="#记一次MyBatis试手项目" class="headerlink" title="记一次MyBatis试手项目"></a>记一次MyBatis试手项目</h1><h2 id="▲我踩的坑▲"><a href="#▲我踩的坑▲" class="headerlink" title="▲我踩的坑▲"></a><font color="red">▲我踩的坑▲</font></h2><p>一.</p><pre><code class="XML">&lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>artifactId一开始写成了servlet-api  这样子是下载不到新版本的</p><p>二. </p><p>mybatis.xml中url：</p><pre><code>url=jdbc:mysql://localhost:3306/mydb?serverTimezone=Asia/Shanghai</code></pre><p>增加?serverTimezone=Asia/Shanghai的原因：</p><p>当JDBC与Mysql服务器建立连接时，如果我们没有给JDBC指定时区，JDBC就会取Mysql服务器的默认时区，也就是CST，而它又把CST理解成了美国中部时间，结果就使用了美国中部时间的时区，而不是后端系统服务器的时区。</p><ul><li>解决办法</li></ul><ol><li>设置Tidb服务器的时区为我们想要的时区，比如UTC+00，或者UTC+08;</li><li>重新配置后端系统连接数据库服务器的URL，添加参数serverTimezone=Asia/Shanghai</li></ol><ul><li>总结</li></ul><p>在和数据库打交道的时候一定要注意时区问题，尤其是针对涉及国际化的业务来说，各个服务器的时区可能有很大差异，如果不显示的指定统一的时区，很容易导致混乱。</p><p>三. </p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>创建项目</p></li><li><p>pom.xml中添加<packing>war</packing>//一旦开始部署就是已war包的形式部署</p></li><li><p>观察项目结构</p><blockquote><p>java源代码  resources配置文件  </p><p>新建webapp文件夹（存放页面）→WEB-INF→web.xml(项目的配置文件)</p><p>随便找一个其他项目web.xml复制到该项目的web.xml即可，且修改项目名称</p></blockquote></li><li><p>创建项目主页index.jsp</p><blockquote><p>先进行测试（project structure中加入web Arfifacts）//deploy能同步信息</p><p>引入bootstrap和jQuery（导入到webapp\lib）</p><pre><code class="jsp">&lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap-3.3.7/dist/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;lib/2.2.4/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>创建结果如下：</p></blockquote></li></ol><p>5.创建数据库xiaoben→表：thing</p><pre><code class="mysql">CREATE TABLE thing(    id INT AUTO_INCREMENT PRIMARY KEY COMMENT &#39;记录编号&#39;,    me VARCHAR(20) NOT NULL COMMENT &#39;记录人物&#39;,    others VARCHAR(20) NOT NULL COMMENT &#39;相关对象&#39;,    gob VARCHAR(100) COMMENT   &#39;事情好坏&#39;,    Rtime DATETIME COMMENT   &#39;记录时间&#39;,    Dtime VARCHAR(40)   COMMENT   &#39;代办时间&#39;,    place VARCHAR(100)  COMMENT   &#39;发生地点&#39;,    content VARCHAR(1000) COMMENT &#39;内容&#39;) DEFAULT CHARSET &quot;utf8&quot;;</code></pre><p>6.pom.xml中增加依赖</p><ul><li><p>mybatis和mysql连接驱动</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.4.3&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.17&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li></ul><p>7.增加mybatis配置文件</p><p>resources中创建mybatis-config.xml → 从mybatis官方文档中复制结构（ctrl+alt+l可以格式化代码）→</p><p>创建db.properties(以value形式存在，且在mybatis-config.xml中引用)</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;mapper/usersMapper.xml&quot;/&gt;    &lt;/mappers&gt;    &lt;!--这是mybatis官方文档给的结构--&gt;&lt;/configuration&gt;</code></pre><p>db.properties：</p><pre><code class="properties">driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mydb?serverTimezone=Asia/Shanghaiusername=rootpassword=mjj666123</code></pre><ol start="8"><li>创建映射配置文件（resources/mapper/userMapper.xml）</li></ol><p>参考官方文档复制</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper 用于定义一个映射配置文件的根节点namespace属性是用来配置命名空间，主要进行session级别的缓存管理命名空间默认情况下，使用我们当前操作的实体类的全路径--&gt;&lt;mapper namespace=&quot;com.mjj.entity.thing&quot;&gt;&lt;/mapper&gt;</code></pre><ol start="9"><li><p>创建实体类（java/com.mjj.entity/thing）</p><pre><code class="java">package com.mjj.entity;import java.util.Date;public class thing {    private Integer id;//事件编号    private String me;//主人    private String others;//被记录人    private String gob;//事件好坏    private Date Rtime;//创建时间    private String Dtime;//代办时间    private String place;//发生地点    private String content;//详细内容    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getMe() {        return me;    }    public void setMe(String me) {        this.me = me;    }    public String getOthers() {        return others;    }    public void setOthers(String others) {        this.others = others;    }    public String getGob() {        return gob;    }    public void setGob(String gob) {        this.gob = gob;    }    public Date getRtime() {        return Rtime;    }    public void setRtime(Date rtime) {        Rtime = rtime;    }    public String getDtime() {        return Dtime;    }    public void setDtime(String dtime) {        Dtime = dtime;    }    public String getPlace() {        return place;    }    public void setPlace(String place) {        this.place = place;    }    public String getContent() {        return content;    }    public void setContent(String content) {        this.content = content;    }}</code></pre></li><li><p>然后再uesrMapper.xml中的namespace添加实体类的路径如下</p></li></ol><pre><code class="xml">&lt;mapper namespace=&quot;com.mjj.entity.thing&quot;&gt;&lt;/mapper&gt;</code></pre><ol start="11"><li>主配置文件引入映射文件</li></ol><pre><code class="xml">&lt;mappers&gt;       &lt;mapper resource=&quot;mapper/usersMapper.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><blockquote><p>resource:mybatis-config.xml</p><p>InputStream</p><p>SqlSessionFactory</p><p>SqlSession</p><p>执行我们的配置好的SQL语句</p></blockquote><ol start="12"><li>创建（com.mjj.utils/SqlSessionFactoryUtils）</li></ol><pre><code class="java">package com.mjj.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.sql.SQLException;public class SqlSessionFactoryUtils {    private static String RESOURCE=&quot;mybatis-config.xml&quot;;    private static SqlSessionFactory sqlSessionFactory;    private static ThreadLocal&lt;SqlSession&gt; threadLocal=new ThreadLocal&lt;SqlSession&gt;();    /*    * 创建一个初始化SqlSessionFactory方法    * */    public static void initSqlSessionFactory(){        try {            InputStream inputStream= Resources.getResourceAsStream(RESOURCE);            sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream);        } catch (IOException e) {            e.printStackTrace();        }    }    /*    * 获取工厂对象的方法    *    * */    public SqlSessionFactory getSqlSessionFactory(){        return sqlSessionFactory;    }//    关闭SqlSession的方法    public static void close(){        SqlSession session=threadLocal.get();        if(session!=null){            session.close();            threadLocal.set(null);        }    }}</code></pre><ol start="13"><li>创建（com.mjj.listener/InitSqlSessionListener.java）</li></ol><pre><code class="java">package com.mjj.listener;import com.mjj.utils.SqlSessionFactoryUtils;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;@WebListenerpublic class InitSqlSessionListener implements ServletContextListener {    public void contextInitialized(ServletContextEvent servletContextEvent) {        System.out.println(&quot;容器加载中&quot;);        //初始化我们的SqlSessionFactory对象        SqlSessionFactoryUtils.initSqlSessionFactory();    }    public void contextDestroyed(ServletContextEvent servletContextEvent) {        System.out.println(&quot;容器销毁中&quot;);        //关闭SqlSession对象        SqlSessionFactoryUtils.close();    }}</code></pre><p>14.创建（com.mjj.dao/thingDao）</p><pre><code class="java">package com.mjj.dao;import com.mjj.entity.thing;import com.mjj.utils.SqlSessionFactoryUtils;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class thingDao {    private SqlSession sqlSession= SqlSessionFactoryUtils.getSqlSessionFactory().openSession();    private List&lt;thing&gt; list;    public List&lt;thing&gt; findAll(){        try {            list=sqlSession.selectList(&quot;findAll&quot;);        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        }        return list;    }}</code></pre><p>关于findAll配置，在resources/mapper/usersMapper.xml中进行配置</p><p>select标签中进行配置</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mjj.entity.thing&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.mjj.entity.thing&quot;&gt;        select * from thing    &lt;/select&gt;&lt;/mapper&gt;</code></pre><ol start="15"><li>引入jstl</li></ol><pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></pre><pre><code class="xml">&lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;jstl&lt;/artifactId&gt;        &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>16.创建Servlet/NoteFindServlet</p><pre><code class="java">package servlet;import Dao.thingDao;import entity.thing;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@WebServlet(&quot;/index&quot;)public class NoteFindServlet extends HttpServlet {    private thingDao thDao= new thingDao();    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doPost(req, resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        List&lt;thing&gt; list=thDao.findAll();        req.setAttribute(&quot;thingList&quot;,list);        req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);    }}</code></pre><ol start="17"><li><p>创建home.jsp 将请求转发至index.jsp  同时修改web.xml的<welcome-file></welcome-file></p><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: Lenovo  Date: 2019/8/11  Time: 11:47  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;%        response.sendRedirect(&quot;index&quot;);    %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>对index.jsp进行修改</p><ul><li>引入jstl标签以及依赖</li><li>foreach循环</li></ul><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: Lenovo  Date: 2019/8/7  Time: 12:15  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;马嘉骏的小本本&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt;    &lt;script src=&quot;lib/2.2.4/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;page-header&quot;&gt;            &lt;h1&gt;&lt;span class=&quot;glyphicon glyphicon-heart&quot;&gt;&lt;/span&gt;                马嘉骏的小本本           &lt;small&gt;            记录每件事&lt;/small&gt;&lt;/h1&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;jumbotron&quot;&gt;            &lt;h1&gt;记录点滴&lt;/h1&gt;            &lt;p&gt;当他回首往事的时候，他不会因为虚度年华而悔恨，也不会因为碌碌无为而羞耻&lt;/p&gt;            &lt;p&gt;&lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;获取更多&lt;/a&gt;&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;table class=&quot;table table-hover table-striped&quot;&gt;            &lt;tr&gt;                &lt;th&gt;记录编号&lt;/th&gt;                &lt;th&gt;记录人物&lt;/th&gt;                &lt;th&gt;相关对象&lt;/th&gt;                &lt;th&gt;事物好坏&lt;/th&gt;                &lt;th&gt;记录时间&lt;/th&gt;                &lt;th&gt;代办时间&lt;/th&gt;                &lt;th&gt;发生地点&lt;/th&gt;                &lt;th&gt;详细内容&lt;/th&gt;                &lt;th&gt;操作&lt;/th&gt;            &lt;/tr&gt;            &lt;c:forEach var=&quot;thing&quot; items=&quot;${thingList}&quot;&gt;                &lt;tr&gt;                    &lt;td&gt;${thing.id}&lt;/td&gt;                    &lt;td&gt;${thing.me}&lt;/td&gt;                    &lt;td&gt;${thing.others}&lt;/td&gt;                    &lt;td&gt;${thing.gob}&lt;/td&gt;                    &lt;td&gt;${thing.rtime}&lt;/td&gt;                    &lt;td&gt;${thing.dotime}&lt;/td&gt;                    &lt;td&gt;${thing.place}&lt;/td&gt;                    &lt;td&gt;${thing.content}&lt;/td&gt;                    &lt;td&gt;                        &lt;a href=&quot;&quot;&gt;查看&lt;/a&gt;                        &lt;a href=&quot;&quot;&gt;修改&lt;/a&gt;                        &lt;a href=&quot;&quot;&gt;删除&lt;/a&gt;                    &lt;/td&gt;                &lt;/tr&gt;            &lt;/c:forEach&gt;        &lt;/table&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><font color="red">这边要特别注意一下 ：在json形式传回的数据 中  类中的属性首字母是默认小写的  （即使在类中属性的首个字母是大写 传过来都是小写的形式）</font></p><p><font color="red"><strong>所以返回属性必须全部是小写 如${thing.rtime}</strong></font></p></li></ol><blockquote><p><font color="red"><strong><em>接下来就是查询阶段的编写</em></strong></font></p></blockquote><ol start="19"><li>thingDao中添加findById</li></ol><pre><code class="java">package Dao;import utils.SqlSessionFactoryUtils;import entity.thing;import org.apache.ibatis.session.SqlSession;import java.util.List;public class thingDao {    private SqlSession sqlSession;    private List&lt;thing&gt; list;    private thing thi;    private SqlSession getSession(){        sqlSession= SqlSessionFactoryUtils.getSqlSessionFactory().openSession();        return sqlSession;    }    public List&lt;thing&gt; findAll(){        try {            list=getSession().selectList(&quot;findAll&quot;);        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        }        return list;    }    //添加部分    public thing findById(Integer id){        try {            thi=getSession().selectOne(&quot;findById&quot;, id);        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        }        return thi;    }}</code></pre><ol start="21"><li>usersMapper.xml中添加findById的sql语句</li></ol><pre><code class="mysql">&lt;select id=&quot;findById&quot; resultType=&quot;entity.thing&quot;&gt;        select * from thing where id=#{id}&lt;/select&gt;</code></pre><ol start="22"><li>创建Servlet/thingFindServlet.java</li></ol><pre><code class="java">package servlet;        import Dao.thingDao;        import entity.thing;        import javax.servlet.ServletException;        import javax.servlet.annotation.WebServlet;        import javax.servlet.http.HttpServlet;        import javax.servlet.http.HttpServletRequest;        import javax.servlet.http.HttpServletResponse;        import java.io.IOException;        import java.util.List;@WebServlet(&quot;/index&quot;)public class NoteFindServlet extends HttpServlet {    private thingDao thDao= new thingDao();    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doPost(req, resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        List&lt;thing&gt; list=thDao.findAll();        req.setAttribute(&quot;thingList&quot;,list);        req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);    }}</code></pre><ol start="23"><li>查看页面的编写detail.jsp</li></ol><pre><code class="jsp">&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%--  Created by IntelliJ IDEA.  User: Lenovo  Date: 2019/8/14  Time: 15:19  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;马嘉骏的小本本&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt;    &lt;script src=&quot;lib/2.2.4/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;page-header&quot;&gt;            &lt;h1&gt;&lt;span class=&quot;glyphicon glyphicon-heart&quot;&gt;&lt;/span&gt;                马嘉骏的小本本           &lt;small&gt;            记录每件事&lt;/small&gt;&lt;/h1&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;jumbotron&quot;&gt;            &lt;h1&gt;记录点滴&lt;/h1&gt;            &lt;p&gt;当他回首往事的时候，他不会因为虚度年华而悔恨，也不会因为碌碌无为而羞耻&lt;/p&gt;            &lt;p&gt;&lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;获取更多&lt;/a&gt;&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;c:set var=&quot;thing&quot; value=&quot;${thing}&quot;&gt;&lt;/c:set&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-8 col col-md-offset-2&quot;&gt;            &lt;form class=&quot;form-horizontal&quot;&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label class=&quot;col-sm-2 control-label&quot;&gt;记录编号&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;p class=&quot;form-control-static&quot;&gt;${thing.id}&lt;/p&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;me&quot; class=&quot;col-sm-2 control-label&quot;&gt;记录人物&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;me&quot; value=&quot;${thing.me}&quot; name=&quot;me&quot; placeholder=&quot;请输入记录人物&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;others&quot; class=&quot;col-sm-2 control-label&quot;&gt;相关对象&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;others&quot; value=&quot;${thing.others}&quot; name=&quot;others&quot; placeholder=&quot;请输入相关对象&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;gob&quot; class=&quot;col-sm-2 control-label&quot;&gt;&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;gob&quot; value=&quot;${thing.gob}&quot; name=&quot;gob&quot; placeholder=&quot;请输入事情好坏&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label class=&quot;col-sm-2 control-label&quot;&gt;记录时间&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;p class=&quot;form-control-static&quot;&gt;                            &lt;fmt:formatDate value=&quot;${thing.rtime}&quot; &gt;&lt;/fmt:formatDate&gt;                        &lt;/p&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;dotime&quot; class=&quot;col-sm-2 control-label&quot;&gt;&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;dotime&quot; value=&quot;${thing.dotime}&quot; name=&quot;dotime&quot; placeholder=&quot;请输入代办时间&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;place&quot; class=&quot;col-sm-2 control-label&quot;&gt;&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;place&quot; value=&quot;${thing.place}&quot; name=&quot;place&quot; placeholder=&quot;请输入事情发生地点&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;content&quot; class=&quot;col-sm-2 control-label&quot;&gt;&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;content&quot; value=&quot;${thing.content}&quot; name=&quot;content&quot; placeholder=&quot;请输入事情详细内容&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/form&gt;            &lt;div class=&quot;form-group&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;提交数据更新&quot; class=&quot;btn btn-primary&quot;&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="24"><li><p>sql动态语句查询</p><p>usersMapper.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper 用于定义一个映射配置文件的根节点namespace属性是用来配置命名空间，主要进行session级别的缓存管理命名空间默认情况下，使用我们当前操作的实体类的全路径--&gt;&lt;mapper namespace=&quot;entity.thing&quot;&gt;    &lt;select id=&quot;findThing&quot; resultType=&quot;entity.thing&quot;&gt;        select * from thing        &lt;if test=&quot;id!=null&quot;&gt;          where id=#{id}        &lt;/if&gt;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>实体类中thing添加构造方法</p><pre><code class="java">    public thing(){    }    public thing(Integer id) {        this.id = id;    }</code></pre><p>Dao中改变函数名，以及参数</p><pre><code class="java">package Dao;import utils.SqlSessionFactoryUtils;import entity.thing;import org.apache.ibatis.session.SqlSession;import java.util.List;public class thingDao {    private SqlSession sqlSession;    private List&lt;thing&gt; list;    private thing thi;    private SqlSession getSession(){        sqlSession= SqlSessionFactoryUtils.getSqlSessionFactory().openSession();        return sqlSession;    }    public List&lt;thing&gt; findAll(){        try {            list=getSession().selectList(&quot;findThing&quot;);        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        }        return list;    }    public thing findById(Integer id){        try {            thi=getSession().selectOne(&quot;findThing&quot;,new thing(id));        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        }        return thi;    }}</code></pre></li><li><p>自定义映射关系集合：主要包含对于一些自定义操作的配置，如不一致的属性和字段</p><p>usersMapper.xml（result配置，主要配置普通属性，column表示配置的是数据库字段名称 property配置的是实体类的属性名称）</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper 用于定义一个映射配置文件的根节点namespace属性是用来配置命名空间，主要进行session级别的缓存管理命名空间默认情况下，使用我们当前操作的实体类的全路径--&gt;&lt;mapper namespace=&quot;entity.thing&quot;&gt;    &lt;!--&lt;select id=&quot;findThing&quot; resultType=&quot;entity.thing&quot;&gt;--&gt;    &lt;select id=&quot;findThing&quot; resultMap=&quot;findthing&quot;&gt;        select * from thing        &lt;if test=&quot;id!=null&quot;&gt;          where id=#{id}        &lt;/if&gt;    &lt;/select&gt;    &lt;resultMap id=&quot;findthing&quot; type=&quot;entity.thing&quot;&gt;        &lt;result column=&quot;me&quot; property=&quot;wo&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;</code></pre></li><li><p>log4j的使用</p></li></ol><p>引入依赖</p><pre><code class="xml"> &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt;</code></pre><p>创建resources/log4j.properties</p><pre><code class="properties">log4j.rootLogger=DEBUG, A1log4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n</code></pre><p>在servlet中使用</p><pre><code class="java">private Logger log=loggger.getlogger(thingFindServlet.class); protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String id=req.getParameter(&quot;id&quot;);        log.info(&quot;获取到查询参数id→→&quot;+id);        thing thi= tDao.findById(Integer.parseInt(id));        log.info(&quot;查询数完成，查询到的数据：&quot;+thi.toString());        req.setAttribute(&quot;thing&quot;,thi);        req.getRequestDispatcher(&quot;detail.jsp&quot;).forward(req,resp);    }</code></pre><p>log.info便会在日志记录中输出</p><p><font color="red">27.添加语句</font></p><p>userMapper</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--mapper 用于定义一个映射配置文件的根节点namespace属性是用来配置命名空间，主要进行session级别的缓存管理命名空间默认情况下，使用我们当前操作的实体类的全路径--&gt;&lt;mapper namespace=&quot;entity.thing&quot;&gt;    &lt;!--&lt;select id=&quot;findThing&quot; resultType=&quot;entity.thing&quot;&gt;--&gt;    &lt;select id=&quot;findThing&quot; resultMap=&quot;findthing&quot;&gt;        select * from thing        &lt;if test=&quot;id!=null&quot;&gt;          where id=#{id}        &lt;/if&gt;    &lt;/select&gt;    &lt;resultMap id=&quot;findthing&quot; type=&quot;entity.thing&quot;&gt;        &lt;result column=&quot;me&quot; property=&quot;wo&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;Dtime&quot; property=&quot;dotime&quot;&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;sql id=&quot;thing_fields&quot;&gt;        me,others,gob,Rtime,Dtime,place,content    &lt;/sql&gt;    &lt;insert id=&quot;addThing&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;        insert into thing(&lt;include refid=&quot;thing_fields&quot;&gt;&lt;/include&gt;)        value(#{wo},#{others},#{gob},#{rtime},#{dotime},#{place},#{content})    &lt;/insert&gt;    &lt;update id=&quot;updatething&quot;&gt;        update thing set me=#{wo},        others=#{others},        gob=#{gob},        Rtime=#{Rtime},        Dtime=#{Dtime},        place=#{place},        content=#{content},        ach=#{ach}        where id=#{id}    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>addThing.jsp</p><pre><code class="jsp">&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%--  Created by IntelliJ IDEA.  User: Lenovo  Date: 2019/8/14  Time: 15:19  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;马嘉骏的小本本&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;lib/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt;    &lt;script src=&quot;lib/2.2.4/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;lib/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;page-header&quot;&gt;            &lt;h1&gt;&lt;span class=&quot;glyphicon glyphicon-heart&quot;&gt;&lt;/span&gt;                马嘉骏的小本本           &lt;small&gt;            记录每件事&lt;/small&gt;&lt;/h1&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;jumbotron&quot;&gt;            &lt;h1&gt;记录点滴&lt;/h1&gt;            &lt;p&gt;当他回首往事的时候，他不会因为虚度年华而悔恨，也不会因为碌碌无为而羞耻&lt;/p&gt;            &lt;p&gt;&lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;获取更多&lt;/a&gt;&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-8 col col-md-offset-2&quot;&gt;            &lt;form class=&quot;form-horizontal&quot; action=&quot;${pageContext.request.contextPath}/addThing&quot;&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;me&quot; class=&quot;col-sm-2 control-label&quot;&gt;记录人物&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;me&quot;  name=&quot;me&quot; placeholder=&quot;请输入记录人物&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;others&quot; class=&quot;col-sm-2 control-label&quot;&gt;相关对象&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;others&quot;  name=&quot;others&quot; placeholder=&quot;请输入相关对象&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;gob&quot; class=&quot;col-sm-2 control-label&quot;&gt;事情好坏&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;gob&quot;  name=&quot;gob&quot; placeholder=&quot;请输入事情好坏&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;dotime&quot; class=&quot;col-sm-2 control-label&quot;&gt;代办时间&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;dotime&quot; name=&quot;dotime&quot; placeholder=&quot;请输入代办时间&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;place&quot; class=&quot;col-sm-2 control-label&quot;&gt;发生地点&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;place&quot; name=&quot;place&quot; placeholder=&quot;请输入事情发生地点&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;label for=&quot;content&quot; class=&quot;col-sm-2 control-label&quot;&gt;详细内容&lt;/label&gt;                    &lt;div class=&quot;col-sm-10&quot;&gt;                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;content&quot; name=&quot;content&quot; placeholder=&quot;请输入事情详细内容&quot;&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;form-group&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;提交数据更新&quot; class=&quot;btn btn-primary&quot;&gt;                &lt;/div&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>thingDao</p><pre><code class="java">package Dao;import utils.SqlSessionFactoryUtils;import entity.thing;import org.apache.ibatis.session.SqlSession;import java.util.List;public class thingDao {    private SqlSession sqlSession;    private List&lt;thing&gt; list;    private thing thi;    private SqlSession getSession(){        sqlSession= SqlSessionFactoryUtils.getSqlSessionFactory().openSession();        return sqlSession;    }    public List&lt;thing&gt; findAll(){        try {            list=getSession().selectList(&quot;findThing&quot;);        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        }        return list;    }    public thing findById(Integer id){        try {            thi=getSession().selectOne(&quot;findThing&quot;,new thing(id));        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        }        return thi;    }//    增加一个新用户数据到数据库的方法    public thing addThing(thing thi){        try {            //返回值：是insert执行过程中影响的行数            getSession().insert(&quot;addThing&quot;,thi);            sqlSession.commit();        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        }        return thi;    }//    用于修改事件的方法    public thing updateThing(thing thi){        try {            getSession().update(&quot;updatething&quot;,thi);            sqlSession.commit();        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        }        return thi;    }}</code></pre><p>thingAddServlet</p><pre><code class="java">package servlet;import Dao.thingDao;import entity.thing;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Date;@WebServlet(&quot;/addThing&quot;)public class thingAddServlet extends HttpServlet {    private thingDao thingdao=new thingDao();    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {       this.doPost(req, resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //获取要添加的用户数据        String me=req.getParameter(&quot;me&quot;);        String others=req.getParameter(&quot;others&quot;);        String gob=req.getParameter(&quot;gob&quot;);        String dotime=req.getParameter(&quot;dotime&quot;);        String place=req.getParameter(&quot;place&quot;);        String content=req.getParameter(&quot;content&quot;);        //根据用户数据创建一个用户对象        thing thi=new thing(me,others,gob,new Date(),dotime,place,content);        //将对象用户添加到数据库中        thi=thingdao.addThing(thi);        //查看刚新增的用户数据        resp.sendRedirect(&quot;detail?id=&quot; + thi.getId());    }}</code></pre><p><font color="red">28.修改语句</font></p><p>映射配置文件 usersMapper</p><pre><code class="xml">&lt;update id=&quot;updatething&quot;&gt;        update thing set me=#{wo},        others=#{others},        gob=#{gob},        Rtime=#{Rtime},        Dtime=#{Dtime},        place=#{place},        content=#{content},        ach=#{ach}        where id=#{id}&lt;/update&gt;</code></pre><p>dao/thingDao</p><pre><code class="java">package Dao;import utils.SqlSessionFactoryUtils;import entity.thing;import org.apache.ibatis.session.SqlSession;import java.util.List;public class thingDao {    private SqlSession sqlSession;    private List&lt;thing&gt; list;    private thing thi;    private SqlSession getSession(){        sqlSession= SqlSessionFactoryUtils.getSqlSessionFactory().openSession();        return sqlSession;    }    //    用于修改事件的方法    public thing updateThing(thing thi){        try {            getSession().update(&quot;updatething&quot;,thi);            sqlSession.commit();        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        }        return thi;    }}</code></pre><p>servlet/thingUpdataServlet</p><pre><code class="java">package servlet;import Dao.thingDao;import entity.thing;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/updatething&quot;)public class thingUpdataServlet extends HttpServlet {    private thingDao thingdao=new thingDao();    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doPost(req, resp);    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //获取用户要更新的数据        String id=req.getParameter(&quot;id&quot;);        String me=req.getParameter(&quot;me&quot;);        String others=req.getParameter(&quot;others&quot;);        String gob=req.getParameter(&quot;gob&quot;);        String dotime=req.getParameter(&quot;dotime&quot;);        String place=req.getParameter(&quot;place&quot;);        String content=req.getParameter(&quot;content&quot;);        //创建事件对象        thing thi=new thing(Integer.parseInt(id),me,others,gob,dotime,place,content);        //提交更新        thingdao.updateThing(thi);        //查看更新后的数据        resp.sendRedirect(&quot;detail?id=&quot;+thi.getId());    }}</code></pre><p><font color="red">29.删除语句</font></p><p>usersMapper.xml</p><p>mapper标签中添加</p><pre><code class="xml">&lt;delete id=&quot;delthing&quot;&gt;     delete from thing where id=#{id}&lt;/delete&gt;</code></pre><p>Dao/thingDao.java</p><pre><code class="java">public void deletething(Integer id){        try {            getSession().delete(&quot;delthing&quot;,id);            sqlSession.commit();        } catch (Exception e) {            e.printStackTrace();        } finally {            sqlSession.close();        } }</code></pre><p>servlet/thingDeleteServlet</p><pre><code></code></pre>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2019/08/07/MyBatis/"/>
    <url>/2019/08/07/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="MyBatis概述"><a href="#MyBatis概述" class="headerlink" title="MyBatis概述"></a>MyBatis概述</h2><h3 id="1-ORM模型简介"><a href="#1-ORM模型简介" class="headerlink" title="1. ORM模型简介"></a>1. ORM模型简介</h3><ul><li><p>object relation mapping</p><table><thead><tr><th align="center">object</th><th align="center">Mapping</th><th align="center">Relation</th></tr></thead><tbody><tr><td align="center">xxx.java</td><td align="center">XML</td><td align="center">dbf</td></tr></tbody></table><blockquote><p>传统JDBCC程序的设计缺陷</p><ul><li>大量配置信息硬编码</li><li>大量的无关业务处理的编码</li><li>扩展优化极为不便</li></ul></blockquote></li></ul><h3 id="2-MyBatis概述"><a href="#2-MyBatis概述" class="headerlink" title="2. MyBatis概述"></a>2. MyBatis概述</h3><p><strong>MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架</strong></p><ul><li>避免传统JDBC硬编码</li><li>XML配置或者注解</li><li>POJO对象和数据库记录直接映射</li><li>完善的文档支持</li></ul><h3 id="3-MyBatis使用优势及应用场景"><a href="#3-MyBatis使用优势及应用场景" class="headerlink" title="3.MyBatis使用优势及应用场景"></a>3.MyBatis使用优势及应用场景</h3><h4 id="使用优势"><a href="#使用优势" class="headerlink" title="使用优势"></a>使用优势</h4><ul><li>简单易学、快速上手、学习成本低</li><li>数据库交互信息配置化</li><li>动态SQL处理</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><p>更加关注SQL优化的项目</p></li><li><p>需求频繁更新改动的项目</p></li></ul><h2 id="MyBatis的环境搭建"><a href="#MyBatis的环境搭建" class="headerlink" title="MyBatis的环境搭建"></a>MyBatis的环境搭建</h2><h3 id="MyBatis的下载"><a href="#MyBatis的下载" class="headerlink" title="MyBatis的下载"></a>MyBatis的下载</h3><p><a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/</a></p><h3 id="项目中引入MyBatis支持"><a href="#项目中引入MyBatis支持" class="headerlink" title="项目中引入MyBatis支持"></a>项目中引入MyBatis支持</h3><p>maven方式引入</p><ul><li>查询配置<ul><li><a href="http://mvnrepositiry.com查询maven依赖配置" target="_blank" rel="noopener">http://mvnrepositiry.com查询maven依赖配置</a></li><li>maven项目的pom.xml中添加配置</li><li>查看项目依赖</li><li>了解maven本地仓库</li></ul></li></ul><h3 id="入门程序（MyBatis核心API操作过程）"><a href="#入门程序（MyBatis核心API操作过程）" class="headerlink" title="入门程序（MyBatis核心API操作过程）"></a>入门程序（MyBatis核心API操作过程）</h3><p>mybatis配置</p><ul><li><p>mybatis.xml主配置文件（从文档中获取再更改）</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test1?serverTimezone=Asia/Shanghai&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;mjj666123&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;mapper/usersMapper.xml&quot;&gt;&lt;/mapper&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre></li><li><p>***Mapper.xml映射配置文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace 命名空间      通常情况，命名空间的值，就是当前操作实体类的全名称--&gt;&lt;mapper namespace=&quot;mjj.Users&quot;&gt;    &lt;select id=&quot;usersList&quot; resultType=&quot;mjj.Users&quot;&gt;        select * from tb1  &lt;/select&gt;&lt;/mapper&gt;</code></pre></li><li><p>实体类Users(重写tostring()方法进行输出)</p></li></ul><pre><code class="java">package mjj;public class Users {    private Integer id;    private String user;    private String password;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getUser() {        return user;    }    public void setUser(String user) {        this.user = user;    }    public String getPassword() {        return password;    }    @Override    public String toString() {        return &quot;Users{&quot; +                &quot;id=&quot; + id +                &quot;, user=&#39;&quot; + user + &#39;\&#39;&#39; +                &quot;, password=&#39;&quot; + password + &#39;\&#39;&#39; +                &#39;}&#39;;    }    public void setPassword(String password) {        this.password = password;    }}</code></pre><ul><li>Testdemo(连接数据库)</li></ul><pre><code class="java">import mjj.Users;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.List;public class Testdemo {    @Test    public void testDemo1() throws IOException {        String resource =&quot;mybatis.xml&quot;;        InputStream is=Resources.getResourceAsStream(resource);        //主配置文件和SqlSessionFactory构建工厂类        SqlSessionFactory factory=                new SqlSessionFactoryBuilder().build(is);        //打开和数据库的会话        SqlSession session=factory.openSession();        List&lt;Users&gt; ulist= session.selectList(&quot;usersList&quot;);        for(Users user:ulist){            System.out.println(user.toString());        }        //关闭会话        session.close();    }}</code></pre><h3 id="项目案例演示"><a href="#项目案例演示" class="headerlink" title="项目案例演示"></a>项目案例演示</h3><ul><li><p>项目案列演示</p><p>后台管理系统用户数据维护平台</p><ul><li>所有用户数据查询</li><li>单个用户数据查询</li><li>用户数据修改</li><li>锁定用户账号</li><li>删除用户账号</li><li>彻底删除用户账号</li></ul></li><li><p>数据库数据准备工作</p></li><li><p>界面准备工作</p></li><li><p>MyBatis基础操作</p></li></ul><h3 id="了解MyBatis的工作原理"><a href="#了解MyBatis的工作原理" class="headerlink" title="了解MyBatis的工作原理"></a>了解MyBatis的工作原理</h3><h4 id="基础操作——主配置解析"><a href="#基础操作——主配置解析" class="headerlink" title="基础操作——主配置解析"></a>基础操作——主配置解析</h4><ul><li><p><strong>properties配置加载</strong></p><p>properties配置，用于加载外部的properties配置文件</p></li><li><p><strong>environments环境配置</strong></p><p><strong>environments：</strong>主要用于数据源的配置，可以配置多个数据源</p><p>通过default属性来指定当前项目运行过程中使用的是哪个数据源</p><p><strong>environment：</strong>用于配置一个具体的独立的数据源</p><p>id属性用于给当前数据源定义一个名称，方便我们项目指定</p><p><strong>transactionManager：</strong>用于配置事务管理，默认情况下使用的是JDBC事务管理</p><p><strong>dataSource：</strong>具体数据源的链接信息；type属性用于指定是否使用连接池</p></li><li><p><strong>settings参数设置配置</strong></p></li><li><p><strong>typeAliases别名设置</strong></p></li><li><p><strong>mapper映射加载</strong></p><p><strong>mappers：</strong>主要用于配置我们外部的映射配置文件，在主配置文件中需要引入加载映射配置文件</p></li></ul><h4 id="基础操作——映射配置文件"><a href="#基础操作——映射配置文件" class="headerlink" title="基础操作——映射配置文件"></a>基础操作——映射配置文件</h4><p>mapper 用于定义一个映射配置文件的根节点</p><p>namespace属性是用来配置命名空间，主要进行session级别的缓存，命名空间默认情况下，使用我们当前操作的实体类全路径</p><h4 id="基础操作——查询数据"><a href="#基础操作——查询数据" class="headerlink" title="基础操作——查询数据"></a>基础操作——查询数据</h4><ul><li>映射配置：sql片段</li><li>映射配置：select配置<ul><li>特殊配置：字段和属性不一致时resultMap配置</li></ul></li></ul><h2 id="Mybatis四大对象"><a href="#Mybatis四大对象" class="headerlink" title="Mybatis四大对象"></a>Mybatis四大对象</h2><h3 id="Mybatis核心对象"><a href="#Mybatis核心对象" class="headerlink" title="Mybatis核心对象"></a>Mybatis核心对象</h3><ul><li>ParameterHandler：处理SQL的参数对象</li><li>ResultSetHandler：处理SQL的返回结果集</li><li>StatementHandler：数据库的处理对象，用于执行SQL语句</li><li>Executor：Mybatis的执行器， 用于执行增删改查操作</li></ul><h3 id="Mybatis插件原理"><a href="#Mybatis插件原理" class="headerlink" title="Mybatis插件原理"></a>Mybatis插件原理</h3><ul><li>Mybatis的插件借助于责任链的模式进行对拦截的处理</li><li>使用动态代理对目标对象进行包装，达到拦截的目的</li><li>作用于Mybatis的作用域对象之上</li></ul><h2 id="Mybatis插件开发"><a href="#Mybatis插件开发" class="headerlink" title="Mybatis插件开发"></a>Mybatis插件开发</h2><h4 id="Mybatis插件借口-Interceptor"><a href="#Mybatis插件借口-Interceptor" class="headerlink" title="Mybatis插件借口-Interceptor"></a>Mybatis插件借口-Interceptor</h4><ul><li>Intercept方法，插件的核心方法</li><li>使用plugin方法，生成target的代理对象</li><li>setProperties方法，配置所有参数</li></ul>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet</title>
    <link href="/2019/07/30/Servlet/"/>
    <url>/2019/07/30/Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><ul><li>了解Browser-Server（B/S）模式</li><li>掌握Servlet开发技巧</li><li>掌握Servlet执行原理</li></ul><blockquote><p>软件结构发展史</p><ul><li>单机时代-桌面应用（word）<ul><li>桌面应用俗称单机应用，软件所有数据都保存在电脑本地硬盘中</li><li>优点：易于使用，结构简单</li><li>缺点：数据难以共享、安全性差、更新不及时</li></ul></li><li>联网时代（Client-Server模式）(QQ\WX)<ul><li>Client/Server结构（C/S结构）是指客户端和服务器结构</li><li>优点：数据方便共享、安全性高</li><li>缺点：必须安装客户端、升级与维护困难</li></ul></li><li>互联网时代（Browser-Server模式）<ul><li>broswer-server（B/S）模式即浏览器和服务器架构模式</li><li>优点：开发简单，无需安装客户端，数据易于共享</li><li>缺点：相较于C/S模式，执行速度与用户体验相对较弱</li></ul></li></ul></blockquote><h2 id="Servlet开发步骤"><a href="#Servlet开发步骤" class="headerlink" title="Servlet开发步骤"></a>Servlet开发步骤</h2><ol><li>创建Servlet类，继承HttpServlet</li><li>重写service方法，编写程序代码</li><li>配置web.xml，绑定URL</li></ol><h2 id="Servlet访问方法"><a href="#Servlet访问方法" class="headerlink" title="Servlet访问方法"></a>Servlet访问方法</h2><ul><li><a href="http://IP地址:端口/context-path/url-mapping" target="_blank" rel="noopener">http://IP地址:端口/context-path/url-mapping</a></li><li>远程访问使用IP地址，本地访问localhost(127.0.0.1)</li><li>context-path成为“上下文路径”</li></ul><h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><ul><li>请求参数是指浏览器通过请求向Tomcat提交的数据</li><li>请求参数通常是用户输入的数据，待Servlet进行处理</li><li>参数名1=值1&amp;参数名2=值2&amp;参数名n=…</li></ul><h3 id="Get与Post请求方法"><a href="#Get与Post请求方法" class="headerlink" title="Get与Post请求方法"></a>Get与Post请求方法</h3><ul><li>Get方式是将数据通过URL附加数据显性向服务器发送数据。（默认）<ul><li><a href="http://localhost:8080/FirstServlet/sample?name=zhangsan" target="_blank" rel="noopener">http://localhost:8080/FirstServlet/sample?name=zhangsan</a></li></ul></li><li>Post方式会将数据存放在“请求体”中隐形向服务器发送数据<ul><li><a href="http://localhost:8080/FirstServlet/sample" target="_blank" rel="noopener">http://localhost:8080/FirstServlet/sample</a></li><li>请求体：name=zhangsan</li></ul></li></ul><h3 id="Get与Post处理方式"><a href="#Get与Post处理方式" class="headerlink" title="Get与Post处理方式"></a>Get与Post处理方式</h3><ul><li>所有请求-service()方法</li><li>Get请求-doGet()方法</li><li>Post请求-daPost()方法</li></ul><h3 id="Get与Post应用场景"><a href="#Get与Post应用场景" class="headerlink" title="Get与Post应用场景"></a>Get与Post应用场景</h3><ul><li>Get常用于不包含敏感信息的查询功能<ul><li>例如：<a href="https://www.baidu.com/s?wd=imooc&amp;rsv_spt=1" target="_blank" rel="noopener">https://www.baidu.com/s?wd=imooc&amp;rsv_spt=1</a></li></ul></li><li>Post用于安全性要求较高的功能或者服务器的“写”操作<ul><li>用户登录</li><li>用户注册</li><li>更新公司账目</li></ul></li></ul><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><ul><li>装载 -web.xml</li><li>创建-构造函数</li><li>初始化-init()</li><li>提供服务-servIce()</li><li>销毁-destory()</li></ul>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2019/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/07/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>设计模式是前辈总结的设计经验(对面向对象语言服务)</li><li>设计模式的目标是代码更容易理解，更容易维护</li><li>通过设计模式使代码更可靠</li></ul><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ol><li><p>创建型模式（基本）</p><p>帮助人们如何更加精巧的创建某些对象</p></li><li><p>结构性模式</p><p>创建 重构 优化结构</p></li><li><p>行为性模式</p><p>针对现实行为进行优化</p></li></ol><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul><li>用于隐藏创建对象的细节</li><li>工厂模式核心：工厂类（Factory）</li><li>工厂模式可细节分为简单工厂、工厂方法与抽象工厂</li></ul><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><blockquote><p>客户类—》具体类1/具体类2</p></blockquote><blockquote><hr><p>客户类→工厂类→抽  象  接  口</p><p>​                                  ↑          ↑</p><p>​                          实现类1    实现类2</p><hr></blockquote><h3 id="项目应用-I18N国际化"><a href="#项目应用-I18N国际化" class="headerlink" title="项目应用-I18N国际化"></a>项目应用-I18N国际化</h3><p><strong>用途</strong>：</p><ol><li>作为工厂模式，通过额外增加工厂类隐藏创建类的细节，作为使用者可以不关心底层创建逻辑。</li><li>通过工厂模式，可以使团队或者个人之间分工合作更加明确</li></ol><h3 id="项目应用-多端应用切换"><a href="#项目应用-多端应用切换" class="headerlink" title="项目应用-多端应用切换"></a>项目应用-多端应用切换</h3>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2019/07/30/Maven/"/>
    <url>/2019/07/30/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><ul><li>Maven是项目管理工具，对软件项目提供构建与依赖管理</li><li>Maven是Apache下的Java开源项目</li><li>Maven为Java项目提供统一的管理方式，已成为业界标准</li></ul><h2 id="Maven-的核心特性"><a href="#Maven-的核心特性" class="headerlink" title="Maven 的核心特性"></a>Maven 的核心特性</h2><ul><li>项目设置遵循统一的规则，保证不同开发环境的兼容性</li><li>强大的依赖管理，项目依赖组件自动下载、自动更新</li><li>可扩展的插件机制，使用简单、功能丰富 </li></ul><h2 id="掌握Maven的依赖管理"><a href="#掌握Maven的依赖管理" class="headerlink" title="掌握Maven的依赖管理"></a>掌握Maven的依赖管理</h2><ul><li>Maven利用dependency（依赖）自动下载、管理第三方Jar</li><li>在pom.xml文件中配置项目依赖的第三方组建</li><li>maven自动将依赖从远程仓库下载到本地仓库，并在工程中引用</li></ul><h2 id="掌握Maven的打包方式"><a href="#掌握Maven的打包方式" class="headerlink" title="掌握Maven的打包方式"></a>掌握Maven的打包方式</h2><ul><li>Maven可将Java项目打包为jar、war包</li><li>Maven项目打包是通过Plugins（插件）技术实现</li><li>Maven输出Jar插件：maven-assembly-plugin</li></ul><h2 id="Maven的安装与配置"><a href="#Maven的安装与配置" class="headerlink" title="Maven的安装与配置"></a>Maven的安装与配置</h2><h3 id="idea："><a href="#idea：" class="headerlink" title="idea："></a>idea：</h3><ol><li>Maven.apache.org 下载</li><li>解压</li><li>环境配置 path  bin目录</li><li>idea  settings ——》Bulid，Execution，Deployment——》Bulid Tools——》Maven——》Maven home directory设置 文件目录 即 apache-maven 3.6.1</li><li>project——》maven——》勾选 Create from archetype 选择 webapp——》输入项目名——》Add Maven Property    Name：archetypeCatalog  Value：internal</li></ol><h2 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h2><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>mvn archetype：generate</td><td>创建Maven工程</td></tr><tr><td>mvn compile</td><td>编译源代码</td></tr><tr><td>mvn test</td><td>执行测试用例</td></tr><tr><td>mvn clean</td><td>清除产生项目</td></tr><tr><td>mvn package</td><td>项目打包</td></tr><tr><td>mvn install</td><td>安装到本地仓库</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL数据库</title>
    <link href="/2019/07/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2019/07/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="深入浅出MySQL数据库"><a href="#深入浅出MySQL数据库" class="headerlink" title="深入浅出MySQL数据库"></a>深入浅出MySQL数据库</h1><h2 id="1-什么是数据库？"><a href="#1-什么是数据库？" class="headerlink" title="1.什么是数据库？"></a>1.什么是数据库？</h2><h3 id="数据库-Database-是按照数据结构来组织、存储和管理数据的仓库"><a href="#数据库-Database-是按照数据结构来组织、存储和管理数据的仓库" class="headerlink" title="数据库(Database)是按照数据结构来组织、存储和管理数据的仓库"></a>数据库(Database)是按照数据结构来组织、存储和管理数据的仓库</h3><h3 id="常见数据库"><a href="#常见数据库" class="headerlink" title="常见数据库"></a>常见数据库</h3><ul><li>Oracle</li><li>DB2</li><li>SQL Server</li><li>Postgre SQL</li><li>MySQL</li></ul><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul><li>数据库系统(Database System):DBS<ul><li>数据库(Database)</li><li>数据库管理系统(Database Management System):DBMS</li><li>应用开发工具</li><li>管理员及用户</li></ul></li><li>SQL语言<ul><li>Structured Query Language：结构化查询语言<ul><li>DDL<ul><li>数据定义语言</li></ul></li><li>DML<ul><li>数据操作语言</li></ul></li><li>DQL<ul><li>数据查询语言</li></ul></li><li>DCL<ul><li>数据控制语言</li></ul></li></ul></li></ul></li></ul><h2 id="2-MySQL相关操作"><a href="#2-MySQL相关操作" class="headerlink" title="2.MySQL相关操作"></a>2.MySQL相关操作</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li>my.cnf是MySQL的配置文件</li></ul><h3 id="登陆-退出MySQL"><a href="#登陆-退出MySQL" class="headerlink" title="登陆/退出MySQL"></a>登陆/退出MySQL</h3><ul><li>登陆<ul><li>mysql -uroot -p</li><li>mysql -uroot -proot</li><li>得到版本号<ul><li>mysql -V</li><li>mysql –version</li></ul></li><li>登陆的同时打开指定数据库<ul><li>mysql -uroot -p -D db_name</li></ul></li></ul></li><li>退出<ul><li>exit</li><li>quit</li></ul></li><li>登陆信息中需要掌握的<ul><li>命令行结束符默认使用;或者\g来结束</li><li>可以通过help或者\h或者?加上相关关键字来查看手册</li><li>\c可以取消当前命令的执行</li></ul></li></ul><h3 id="SQL语句语法规范"><a href="#SQL语句语法规范" class="headerlink" title="SQL语句语法规范"></a>SQL语句语法规范</h3><ul><li>常用MySQL的关键字我们需要大写，库名、表名、字段名称等使用小写</li><li>SQL语句支持折行操作，拆分的时候不能把完整单词拆开</li><li>数据库名称、表名称、字段名称不要使用MySQL的保留字，如果必须要使用，需要用反引号``将其括起来</li></ul><h3 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h3><ul><li>SELECT USER()<ul><li>得到登陆的用户</li></ul></li><li>SELECT VERSION()<ul><li>得到MySQL的版本信息</li></ul></li><li>SELECT NOW()<ul><li>得到当前的日期时间</li></ul></li><li>SELECT DATABASE()<ul><li>得到当前打开的数据库</li></ul></li></ul><h2 id="3-数据库相关操作"><a href="#3-数据库相关操作" class="headerlink" title="3.数据库相关操作"></a>3.数据库相关操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul><li>CREATE {DATABASE|SCHEMA} db_name;</li><li>检测数据库名称是否存在，不存在则创建<ul><li>CREATE DATABASE [IF NOT EXISTS] db_name;</li></ul></li><li>在创建数据库的同时指定编码方式<ul><li>CREATE DATABASE [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset;</li></ul></li><li>注意<ul><li>数据库名称最好有意义</li><li>名称不要包含特殊字符或者是MySQL关键字</li></ul></li></ul><h3 id="查看当前服务器下全部数据库"><a href="#查看当前服务器下全部数据库" class="headerlink" title="查看当前服务器下全部数据库"></a>查看当前服务器下全部数据库</h3><ul><li>SHOW DATABASES|SCHEMAS;</li></ul><h3 id="查看指定数据库的详细信息"><a href="#查看指定数据库的详细信息" class="headerlink" title="查看指定数据库的详细信息"></a>查看指定数据库的详细信息</h3><ul><li>SHOW CREATE DATABASE db_name;</li></ul><h3 id="修改指定数据库的编码方式"><a href="#修改指定数据库的编码方式" class="headerlink" title="修改指定数据库的编码方式"></a>修改指定数据库的编码方式</h3><ul><li>ALTER DATABASE db_name [DEFAULT] CHARACTER SET [=] charset;</li></ul><h3 id="打开指定数据库"><a href="#打开指定数据库" class="headerlink" title="打开指定数据库"></a>打开指定数据库</h3><ul><li>USE db_name;</li></ul><h3 id="得到当前打开的数据库"><a href="#得到当前打开的数据库" class="headerlink" title="得到当前打开的数据库"></a>得到当前打开的数据库</h3><ul><li>SELECT DATABASE()|SCHEMA();</li></ul><h3 id="删除指定的数据库"><a href="#删除指定的数据库" class="headerlink" title="删除指定的数据库"></a>删除指定的数据库</h3><ul><li>DROP DATABASE db_name;</li><li>如果数据库存在则删除<ul><li>DROP DATABASE [IF EXISTS] db_name;</li></ul></li></ul><h2 id="4-数据表相关操作"><a href="#4-数据表相关操作" class="headerlink" title="4.数据表相关操作"></a>4.数据表相关操作</h2><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><ul><li>是数据库最重要的组成部分之一，数据是保存在数据表中</li><li>数据表由行(row)和列(column)来组成</li><li>每个数据表中至少有一列，行可以有零行一行或者多行组成</li><li>表名要求唯一，不要包含特殊字符，最好含义明确</li></ul><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><ul><li>CREATE TABLE [IF NOT EXISTS] tbl_name(<br>字段名称 字段类型 [完整性约束条件],<br>字段名称 字段类型 [完整性约束条件],<br>…<br>)ENGINE=存储引擎 CHARSET=编码方式;<ul><li>UNSIGNED<ul><li>无符号，没有负数，从0开始</li></ul></li><li>ZEROFILL<ul><li>零填充，当数据的显示长度不够的时候可以使用前补0的效果填充至指定长度,字段会自动添加UNSIGNED</li></ul></li><li>NOT NULL<ul><li>非空约束，也就是插入值的时候这个字段必须要给值,值不能为空</li></ul></li><li>DEFAULT<ul><li>默认值，如果插入记录的时候没有给字段赋值，则使用默认值</li></ul></li><li>PRIMARY KEY<ul><li>主键，标识记录的唯一性，值不能重复，一个表只能有一个主键，自动禁止为空</li></ul></li><li>AUTO_INCREMENT<ul><li>自动增长，只能用于数值列，而且配合索引使用,默认起始值从1开始，每次增长1</li></ul></li><li>UNIQUE KEY<ul><li>唯一性，一个表中可以有多个字段是唯一索引，同样的值不能重复，但是NULL值除外</li></ul></li><li>FOREIGN KEY<ul><li>外键约束</li></ul></li></ul></li></ul><h3 id="查看当前数据库下已有数据表"><a href="#查看当前数据库下已有数据表" class="headerlink" title="查看当前数据库下已有数据表"></a>查看当前数据库下已有数据表</h3><ul><li>SHOW TABLES;</li><li>SHOW [FULL] TABLES [{FROM | IN} db_name]<br>[LIKE ‘pattern’ | WHERE expr]</li></ul><h3 id="查看指定数据表的详细信息"><a href="#查看指定数据表的详细信息" class="headerlink" title="查看指定数据表的详细信息"></a>查看指定数据表的详细信息</h3><ul><li>SHOW CREATE TABLE tbl_name;</li></ul><h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><ul><li>DESC tbl_name;</li><li>DESCRIBE tbl_name;</li><li>SHOW COLUMNS FROM tbl_name;</li></ul><h3 id="删除指定的数据表"><a href="#删除指定的数据表" class="headerlink" title="删除指定的数据表"></a>删除指定的数据表</h3><ul><li>DROP TABLE [IF EXISTS] tbl_name;</li></ul><h3 id="表结构相关操作"><a href="#表结构相关操作" class="headerlink" title="表结构相关操作"></a>表结构相关操作</h3><ul><li>添加字段<ul><li>ALTER TABLE tbl_name<br>ADD 字段名称 字段属性 [完整性约束条件] [FIRST|AFTER 字段名称]</li></ul></li><li>删除字段<ul><li>ALTER TABLE tbl_name<br>DROP 字段名称</li></ul></li><li>添加默认值<ul><li>ALTER TABLE tbl_name<br>ALTER 字段名称 SET DEFAULT 默认值;</li></ul></li><li>删除默认值<ul><li>ALTER TABLE tbl_name<br>ALTER 字段名称 DROP DEFAULT</li></ul></li><li>修改字段类型、字段属性<ul><li>ALTER TABLE tbl_name<br>MODIFY 字段名称 字段类型 [字段属性] [FIRST | AFTER 字段名称]</li></ul></li><li>修改字段名称、字段类型、字段属性<ul><li>ALTER TABLE tbl_name<br>CHANGE 原字段名称 新字段名称 字段类型 字段属性 [FIRST | AFTER 字段名称]</li></ul></li><li>添加主键<ul><li>ALTER TABLE tbl_name<br>ADD PRIMARY KEY(字段名称)</li></ul></li><li>删除主键<ul><li>ALTER TABLE tbl_name<br>DROP PRIMARY KEY;</li></ul></li><li>添加唯一<ul><li>ALTER TABLE tbl_name<br>ADD UNIQUE KEY|INDEX [index_name] (字段名称)</li></ul></li><li>删除唯一<ul><li>ALTER TABLE tbl_name<br>DROP index_name;</li></ul></li><li>修改数据表名称<ul><li>ALTER TABLE tbl_name<br>RENAME [TO|AS] new_tbl_name</li><li>RENAME TABLE tbl_name TO new_tbl_name;</li></ul></li><li>修改AUTO_INCREMENT的值<ul><li>ALTER TABLE tbl_name AUTO_INCREMENT=值</li></ul></li></ul><h2 id="5-MySQL中的数据类型"><a href="#5-MySQL中的数据类型" class="headerlink" title="5.MySQL中的数据类型"></a>5.MySQL中的数据类型</h2><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><ul><li>整数型</li><li>浮点型</li></ul><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ul><li>CHAR效率高于VARCHAR,CHAR相当于拿空间换时间，VARCHAR拿时间换空间</li><li>CHAR默认存储数据的时候，后面会用空格填充到指定长度；而在检索的时候会去掉后面空格；VARCHAR在保存的时候不进行填充，尾部的空格会留下</li><li>TEXT列不能有默认值,检索的时候不存在大小写转换</li></ul><h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><h3 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h3><h2 id="6-MySQL存储引擎"><a href="#6-MySQL存储引擎" class="headerlink" title="6.MySQL存储引擎"></a>6.MySQL存储引擎</h2><h3 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h3><ul><li>默认MyISAM的表会在磁盘中产生3个文件<ul><li>.frm<ul><li>表结构文件</li></ul></li><li>.MYD<ul><li>数据文件</li></ul></li><li>.MYI<ul><li>索引文件</li></ul></li></ul></li><li>可以在创建的时候指定数据文件和索引文件的存储位置，只有MyISAM表支持<ul><li>DATA DIRECORY [=] 数据保存的绝对路径</li><li>INDEX DIRECTORY [=] 索引文件保存的绝对路径</li></ul></li><li>MyISAM单表最大支持的数据量2的64次方条记录</li><li>每个表最多可以建立64个索引</li><li>如果是复合索引，每个复合索引最多包含16个列，索引值最大长度是1000B</li><li>MyISAM引擎的存储格式<ul><li>定长（FIXED 静态）<ul><li>是指字段中不包含VARCHAR/TEXT/BLOB</li></ul></li><li>动态（DYNAMIC）<ul><li>只要字段中包含了VARCHAR/TEXT/BLOB</li></ul></li><li>压缩（COMPRESSED）<ul><li>myisampack创建</li></ul></li></ul></li></ul><h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h3><ul><li>设计遵循ACID模型，支持事务，具有从服务崩溃中恢复的能力，能够最大限度保护用户的数据</li><li>支持行级锁，可以提升多用户并发时的读写性能</li><li>支持外键，保证数据的一致性和完整性</li><li>InnoDB拥有自己独立的缓冲池，常用的数据和索引都在缓存中</li><li>对于INSERT、UPDATE、DELETE操作，InnoDB会使用一种change buffering的机制来自动优化，还可以提供一致性的读，并且还能够缓存变更的数据，减少磁盘I/O，提高性能</li><li>创建InnoDB表之后会产生两个文件<ul><li>.frm表结构文件</li><li>.ibd,数据和索引存储表空间中</li></ul></li><li>所有的表都需要创建主键，最好是配合上AUTO_INCREMENT,也可以放到经常查询的列作为主键</li></ul><h2 id="7-MySQL数据操作"><a href="#7-MySQL数据操作" class="headerlink" title="7.MySQL数据操作"></a>7.MySQL数据操作</h2><h3 id="添加记录"><a href="#添加记录" class="headerlink" title="添加记录"></a>添加记录</h3><ul><li>INSERT [INTO] tbl_name[(col_name,…)] {VALUE|VALUES}(VALUES…);</li><li>不指定字段名称<ul><li>INSERT tbl_name VALUE(value…)</li><li>需要按照建表时的字段顺序给每一个字段赋值</li></ul></li><li>列出指定字段<ul><li>INSERT tbl_name(字段名称,…) VALUES(值,…)</li></ul></li><li>INSERT … SET的形式<ul><li>INSERT tbl_name SET 字段名称=值,…;</li></ul></li><li>INSERT … SELECT<ul><li>INSERT tbl_name[(字段名称…)] SELECT 字段名称,… FROM  tbl_name [WHERE 条件]</li></ul></li><li>一次添加多条记录<ul><li>INSERT tbl_name[(字段名称,…)] VALUES(值,…),<br>(值,….),<br>(值,…)</li></ul></li></ul><h3 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h3><ul><li>UPDATE tbl_name SET 字段名称=值,字段名称=值 [WHERE 条件]</li><li>如果不添加条件，整个表中的记录都会被更新</li></ul><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><ul><li>DELETE FROM tbl_name [WHERE 条件]</li><li>如果不添加条件，表中所有记录都会被删除</li><li>DELETE 清空数据表的时候不会重置AUTO_INCREMENT的值，可以通过ALTER 语句将其重置为1</li><li>彻底清空数据表<ul><li>TRUNCATE [TABLE] tbl_name;<ul><li>清除表中所有记录</li><li>会重置AUTO_INCREMENT的值</li></ul></li></ul></li></ul><h3 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h3><ul><li><p>SELECT select_expr,… FROM tbl_name<br>[WHERE 条件]<br>[GROUP BY {col_name|position} HAVING 二次筛选]<br>[ORDER BY {col_name|position|expr} [ASC|DESC]]<br>[LIMIT 限制结果集的显示条数] </p></li><li><p>查询表中所有记录</p><ul><li>SELECT * FROM tbl_name;<ul><li>*所有字段</li></ul></li></ul></li><li><p>指定字段的信息</p><ul><li>SELECT 字段名称,… FROM tbl_name</li></ul></li><li><p>库名.表名</p><ul><li>SELECT 字段名称,… FROM db_name.tbl_name;</li></ul></li><li><p>给字段起别名</p><ul><li>SELECT 字段名称 [AS] 别名名称,… FROM db_name.tbl_name; </li></ul></li><li><p>给数据表起别名</p><ul><li>SELECT 字段名称 ,… FROM tbl_name [AS] 别名;</li></ul></li><li><p>表名.字段名的</p><ul><li>SELECT tbl_name.col_name,… FROM tbl_name;</li></ul></li><li><p>WHERE 条件</p><ul><li><p>会筛选出符合条件的记录</p><ul><li><p>比较运算符</p><ul><li><blockquote><blockquote><p>= &lt; &lt;= != &lt;&gt; &lt;=&gt;</p></blockquote></blockquote><ul><li>&lt;=&gt; 和 =的区别<ul><li>&lt;=&gt;可以检测NULL值</li></ul></li></ul></li></ul></li><li><p>IS [NOT] NULL</p><ul><li>检测值是否为NULL或者NOT NULL</li></ul></li><li><p>指定范围</p><ul><li>[NOT] BETWEEN … AND</li></ul></li><li><p>指定集合</p><ul><li>[NOT] IN(值,…)</li></ul></li><li><p>逻辑运算符</p><ul><li>AND<ul><li>逻辑与</li></ul></li><li>OR<ul><li>逻辑或</li></ul></li></ul></li><li><p>匹配字符</p><ul><li>[NOT] LIKE</li><li>%<ul><li>任意长度的字符串</li></ul></li><li>_<ul><li>任意一个字符</li></ul></li></ul></li></ul></li></ul></li><li><p>GROUP BY 分组</p><ul><li>把值相同放到一个组中，最终查询出的结果只会显示组中一条记录</li><li>分组配合GROUP_CONCAT()查看组中某个字段的详细信息</li><li>配合聚合函数使用<ul><li>COUNT()<ul><li>统计记录总数</li><li>如果写的是COUNT(字段名称)，字段中的值为NULL，不统计进来</li><li>写COUNT(*)会统计NULL值</li></ul></li><li>SUM()<ul><li>求和</li></ul></li><li>MAX()<ul><li>求最大值</li></ul></li><li>MIN()<ul><li>求最小值</li></ul></li><li>AVG()<ul><li>求平均值</li></ul></li></ul></li><li>配合WITH ROLLUP关键使用<ul><li>会在记录末尾添加一条记录，是上面所有记录的总和</li></ul></li><li>HAVING子句对分组结果进行二次筛选</li></ul></li><li><p>ORDER BY 排序</p><ul><li>ORDER BY 字段名称 ASC|DESC</li></ul></li><li><p>LIMIT 限制结果集显示条数</p><ul><li>LIMIT 值<ul><li>显示结果集的前几条记录</li></ul></li><li>LIMIT offset,row_count<ul><li>从offset开始，显示几条记录,offset从0开始</li></ul></li></ul></li></ul><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li>笛卡尔积的形式</li><li>内连接的形式<ul><li>查询两个表中符合连接条件的记录</li><li>SELECT 字段名称,… FROM tbl_name1<br>INNER JOIN tbl_name2<br>ON 连接条件</li></ul></li><li>外连接的形式<ul><li>左外连接<ul><li>SELECT 字段名称,… FROM tbl_name1<br>LEFT [OUTER] JOIN tbl_name2<br>ON 条件;</li><li>先显示左表中的全部记录，再去右表中查询复合条件的记录，不符合的以NULL代替</li></ul></li><li>右外连接<ul><li>SELECT 字段名称,… FROM tbl_name1<br>RIGHT [OUTER] JOIN tbl_name2<br>ON 条件;</li><li>先显示右表中的全部记录，再去左表中查询复合条件的记录，不符合的以NULL代替</li></ul></li></ul></li></ul><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><ul><li>只有InnoDB存储引擎支持外键</li><li>创建外键<ul><li>建表时指定外键<ul><li>[CONSTRAINT 外键名称 ]FOREIGN KEY(字段名称) REFERENCES 主表(字段名称)</li><li>子表的外键字段和主表的主键字段类型要相似；如果是数值型要求一致，并且无符号也要一致；如果是字符型，要求类型一致，长度可以不同</li><li>如果外键字段没有创建索引，MySQL会自动帮我们添加索引</li><li>子表的外键关联的必须是父表的主键</li><li>外键约束的参照操作<ul><li>CASCADE<ul><li>从父表删除或更新，子表也跟着删除或者更新，级联的操作</li></ul></li><li>SET NULL<ul><li>从父表删除或者更新记录，并设置子表的外键列为NULL。</li></ul></li><li>NO ACTION | RESTRICT<ul><li>拒绝对父表做更新或者删除操作</li></ul></li></ul></li></ul></li><li>动态添加外键<ul><li>动态添加外键<ul><li>ALTER TABLE tbl_name ADD [CONSTRAINT 外键名称] FOREIGN KEY(外键字段) REFERENCES 主表(主键字段);</li><li>动态添加外键之前表中的记录一定合法的记录，没有脏值，否则外键添加不成功</li></ul></li><li>动态删除外键<ul><li>ALTER TABLE tbl_name<br>DROP FOREIGN KEY fk_name;</li></ul></li></ul></li></ul></li></ul><h3 id="特殊形式的查询"><a href="#特殊形式的查询" class="headerlink" title="特殊形式的查询"></a>特殊形式的查询</h3><ul><li>子查询<ul><li>SELECT 字段名称 FROM tbl_name WHERE col_name=(SELECT col_name FROM tbl_name)</li><li>内层语句查询的结果可以做为外层语句查询的条件</li><li>由IN引发的子查询</li><li>由比较运算符引出子查询</li><li>由EXISTS引发的子查询</li><li>ANY SOME ALL</li><li>INSERT … SELECT</li><li>CREATE … SELECT</li><li>CREATE TABLE tbl_name LIKE tbl_name;</li></ul></li><li>联合查询<ul><li>UNION<ul><li>SELECT 字段名称,… FROM tbl_name1<br>UNION<br>SELECT 字段名称… FROM tbl_name2;</li></ul></li><li>UNION ALL<ul><li>SELECT 字段名称,… FROM tbl_name1<br>UNION ALL<br>SELECT 字段名称… FROM tbl_name2;</li></ul></li><li>UNION ALL 是简单的合并，UNION会去掉表中重复记录</li></ul></li><li>自身连接查询<ul><li>无限级分类的实现形式</li></ul></li></ul><h2 id="8-MYSQL常用函数"><a href="#8-MYSQL常用函数" class="headerlink" title="8.MYSQL常用函数"></a>8.MYSQL常用函数</h2><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul><li>CEIL()<ul><li>进一取整</li></ul></li><li>FLOOR()<ul><li>舍掉小数部分</li></ul></li><li>ROUND()<ul><li>四舍五入</li></ul></li><li>TRUNCATE()<ul><li>截取小数点后几位</li></ul></li><li>MOD()<ul><li>取余数</li></ul></li><li>ABS()<ul><li>取绝对值</li></ul></li><li>POWER()<ul><li>幂运算</li></ul></li><li>PI()<ul><li>圆周率</li></ul></li><li>RAND()或者RAND(X)<ul><li>0~1之间的随机数</li></ul></li><li>SIGN(X)<ul><li>得到数字符号</li></ul></li><li>EXP(X)<ul><li>计算e的x次方</li></ul></li></ul><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h3><h3 id="其它常用函数"><a href="#其它常用函数" class="headerlink" title="其它常用函数"></a>其它常用函数</h3><h2 id="9-图形化工具管理数据库"><a href="#9-图形化工具管理数据库" class="headerlink" title="9.图形化工具管理数据库"></a>9.图形化工具管理数据库</h2><h3 id="BS"><a href="#BS" class="headerlink" title="BS"></a>BS</h3><ul><li>phpmyadmin</li></ul><h3 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h3><ul><li>Sequel Pro</li><li>windows<ul><li>SQLyog</li><li>navit for mysql</li><li>mysql front</li><li>mysql workbench</li></ul></li></ul><h2 id="常用SQL语句-1"><a href="#常用SQL语句-1" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="查看上一步操作产生的警告信息"><a href="#查看上一步操作产生的警告信息" class="headerlink" title="查看上一步操作产生的警告信息"></a>查看上一步操作产生的警告信息</h3><ul><li>SHOW WARNINGS;</li></ul><h3 id="mysql中的注释"><a href="#mysql中的注释" class="headerlink" title="mysql中的注释"></a>mysql中的注释</h3><ul><li><h1 id="注释内容"><a href="#注释内容" class="headerlink" title="注释内容"></a>注释内容</h1></li><li><p>– 注释内容</p></li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XML</title>
    <link href="/2019/07/14/XML/"/>
    <url>/2019/07/14/XML/</url>
    
    <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><blockquote><p>五个方面</p><ol><li>XML介绍与用途</li><li>XML的语法规则</li><li>XML语义约束</li><li>Java解析XML</li><li>XPath路径表达式</li></ol></blockquote><h2 id="XML介绍与用途"><a href="#XML介绍与用途" class="headerlink" title="XML介绍与用途"></a>XML介绍与用途</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol><li><p>全称：E<font color="red">X</font>tensible   <font color="red">M</font>arkup   <font color="red">L</font>anguage</p><p>​            可扩展             标记            语言</p></li><li><p>编写XML就是编写标签，与HTML非常类似，扩展名.xml</p></li><li><p>良好的人机可读性</p><pre><code class="xml">`&lt;employee&gt;    &lt;name&gt;张三&lt;/name&gt;    &lt;age&gt;20&lt;/age&gt;    &lt;height&gt;1.80&lt;/height&gt;&lt;/employee&gt;</code></pre></li></ol><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li>Java程序的配置描述文件（web.xml—web应用配置文件）</li><li>用于保存程序产生的数据</li><li>网络间的数据传输（webservice底层soap协议：）</li></ol><h2 id="语法规则（文档结构）"><a href="#语法规则（文档结构）" class="headerlink" title="语法规则（文档结构）"></a>语法规则（文档结构）</h2><blockquote><ol><li>第一行必须是XML声明</li><li>有且只有一个根节点</li><li>XML标 签的书写规则与HTML相同</li></ol></blockquote><h3 id="XML声明"><a href="#XML声明" class="headerlink" title="XML声明"></a>XML声明</h3><ul><li><p>XML声明说明XML文档的基本信息，包括版本号与字符集，写在XML第一行。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></pre><p>version 代表版本号1.0  encoding UTF-8设置字符集，用于支持中文</p></li></ul><h3 id="XML标签书写规则"><a href="#XML标签书写规则" class="headerlink" title="XML标签书写规则"></a>XML标签书写规则</h3><ol><li><p>合法的标签名</p><ul><li>标签名要有意义</li><li>建议使用英文，小写字母，单词之间使用 “ - “分割。</li><li>建议多级标签之间不要存在重名情况</li></ul></li><li><p>适当的注释与缩进</p><blockquote><p>适当的注释与缩进可以让XML文档更容易阅读</p></blockquote></li><li><p>合理使用属性</p><ul><li>标签属性用于描述标签不可或缺的信息</li><li>对标签分组或者为标签设置Id时常用属性表示</li></ul></li><li><p>处理特殊字符</p><ul><li><p>标签体中，出现”&lt;”、”&gt;”特殊字符，会破坏文档结构。</p><blockquote><p><strong>解决方案1：</strong>使用实体引用。</p><p>XML支持五种实体引用</p><table><thead><tr><th align="center">实体引用</th><th align="center">对应符号</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&amp;It；</td><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&amp;gt；</td><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&amp;amp；</td><td align="center">&amp;</td><td align="center">和号</td></tr><tr><td align="center">&amp;apos；</td><td align="center">‘</td><td align="center">单引号</td></tr><tr><td align="center">&amp;quot；</td><td align="center">“</td><td align="center">双引号</td></tr></tbody></table><p><strong>解决方案2：</strong>使用CDATA标签</p><ul><li>CDATA指的是不应由XML解析器进行解析的文本数据</li><li>“<!--[CDATA[内容]]-->”</li></ul></blockquote></li></ul></li><li><p>有序的子元素</p><ul><li>在XML多层嵌套的子元素中，标签前后顺序应保持一致</li></ul></li></ol><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;teaching-plan&gt;    &lt;course&gt;        &lt;course-name&gt;大学英语&lt;/course-name&gt;        &lt;class-hour&gt;36&lt;/class-hour&gt;        &lt;exam-form&gt;考试&lt;/exam-form&gt;    &lt;/course&gt;    &lt;course&gt;        &lt;course-name&gt;高等数学&lt;/course-name&gt;        &lt;class-hour&gt;70&lt;/class-hour&gt;        &lt;exam-form&gt;考试&lt;/exam-form&gt;    &lt;/course&gt;    &lt;course&gt;        &lt;course-name&gt;计算机应用基础&lt;/course-name&gt;        &lt;class-hour&gt;108&lt;/class-hour&gt;        &lt;exam-form&gt;上机考试&lt;/exam-form&gt;    &lt;/course&gt;&lt;/teaching-plan&gt;</code></pre><h2 id="XML语义约束"><a href="#XML语义约束" class="headerlink" title="XML语义约束"></a>XML语义约束</h2><ul><li>XML文档结构正确，但可能不有效。（如员工档案XML中出现“植物品种”）</li><li>XML予以约束有两种定义方式：DTD与XML Schema</li></ul><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><blockquote><p><strong>DTD</strong>  Document Type Definition 文档类型定义</p><ul><li>DTD扩展名.dta</li><li>利用DTD中的&lt;!ELEMENT&gt;标签，定义XML文档中允许出现的节点和数量，举例如下：</li></ul><pre><code class="xml">&lt;!--定义hr节点下只允许出现一个employee子节点--&gt;&lt;!ELEMENT hr (employee)&gt;&lt;!--必须含有以下下四个节点，且按顺序出现--&gt;&lt;!ELEMENT employee (name,age,salary,department)&gt;&lt;!--定义name标签体只能是文本，#PCDATA代表文本元素&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!--最少出现1个--&gt;&lt;!ELEMENT hr (employee+)&gt;&lt;!--最多出现1个&gt;&lt;!ELEMENT hr (employee?)&gt;&lt;!--可出现0~n个--&gt;&lt;!ELEMENT hr (employee*)&gt;</code></pre><p><font color="red"><u><strong>XML怎么引用DTD文件？</strong></u></font></p><p><strong>回答：</strong></p><p>格式：</p><pre><code>&lt;!DOCTYPE 根节点 SYSTEM &quot;dtd文件路径&quot;&gt;</code></pre><p>示例：</p><pre><code>&lt;!DOCTYPE hr SYSTEM &quot;hr.dtd&quot;&gt;</code></pre><p>DTD的创建和使用</p><ul><li><p>创建(idea)：1.Tools</p><p>​                      2.XML Actions</p><p>​                      3.generate DTD from XML Files</p></li><li><p><font color="red">注意：父节点之后一定要有空格</font></p></li></ul></blockquote><h3 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h3><blockquote><ul><li>XML Schema更复杂提供了更多功能</li><li>XML Schema提供了数据类型、格式限定、数据范围等特性。</li><li>XML Schema是W3C标准。（所以之后通常用XML Schema）</li></ul></blockquote><pre><code class="scheme">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;  &lt;element name=&quot;hr&quot;&gt;      &lt;complexType&gt;        &lt;sequence&gt;          &lt;element name=&quot;employee&quot;&gt;            &lt;complexType&gt;              &lt;sequence&gt;                &lt;element name=&quot;name&quot; type=&quot;string&quot;&gt;&lt;/element&gt;                &lt;element name=&quot;age&quot; type=&quot;integer&quot;&gt;                    &lt;restriction base=&quot;integer&quot;&gt;                        &lt;minInclusive value=&quot;18&quot;&gt;&lt;minInclusive&gt;                        &lt;maxInclusive value=&quot;60&quot;&gt;&lt;maxInclusive&gt;                    &lt;/restriction&gt;                &lt;/element&gt;                &lt;element name=&quot;salary&quot; type=&quot;integer&quot;&gt;&lt;/element&gt;                &lt;element name=&quot;department&quot;&gt;                    &lt;complexType&gt;                      &lt;sequence&gt;                        &lt;element name=&quot;dname&quot; type=&quot;string&quot;&gt;&lt;/element&gt;                        &lt;element name=&quot;address&quot; type=&quot;string&quot;&gt;&lt;/element&gt;                      &lt;/sequence&gt;                    &lt;/complexType&gt;                &lt;/element&gt;              &lt;/sequence&gt;            &lt;/complexType&gt;          &lt;/element&gt;        &lt;/sequence&gt;      &lt;/complexType&gt;  &lt;/element&gt;&lt;/schema&gt;</code></pre><p><font color="red"><strong>Tips:</strong>框架和架构都离不开schema</font></p><h2 id="java解析XML"><a href="#java解析XML" class="headerlink" title="java解析XML"></a>java解析XML</h2><h3 id="DOM文档对象模型"><a href="#DOM文档对象模型" class="headerlink" title="DOM文档对象模型"></a>DOM文档对象模型</h3><ul><li>DOM（Document Object Model)定义了访问和操作XML文档的标准方法，DOM把XML文档作为树结构来查看，能够通过DOM树来读写所有元素。</li></ul><h3 id="Dom4j"><a href="#Dom4j" class="headerlink" title="Dom4j"></a>Dom4j</h3><ul><li>Dom4j是一个易用的、开源的库，用于解析XML。它应用于Java平台，具有性能优异、功能强大和极其易使用的特点 。</li><li>Dom4j将XML视为Document对象</li><li>XML标签被Dom4j定义为Element对象</li></ul><h3 id="Dom4j遍历XML"><a href="#Dom4j遍历XML" class="headerlink" title="Dom4j遍历XML"></a>Dom4j遍历XML</h3><pre><code class="java">package com.imooc.dom4j;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.util.List;public class HrReader{    public void readXml(){        String file =&quot;文件的路径&quot;；        //SAXReader类是读取XML文件的核心类，用于将XML解析后以“树”的形式        SAXReader reader=new SAXReader();        try{            Document document=reader.read(file);            //获取XML的根节点            Element root=document.getRootElement();            //elements方法用于获取指定的标签集合            List&lt;Element&gt; employees=root.elements(&quot;标签名（子节点名）&quot;);            for(Element employee:employ){                System.out.println(employee.elementText(&quot;name&quot;));//获取name节点的文本内容                Attribute att=employee.attribute(&quot;属性名&quot;);                System.out.println(att.getText());            }        }        catch (DocumentException e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        HrReader reader=new HrReader();        reader.readXml();    }}</code></pre><h3 id="利用Dom4j更新XML"><a href="#利用Dom4j更新XML" class="headerlink" title="利用Dom4j更新XML"></a>利用Dom4j更新XML</h3><pre><code class="java">package com.imooc.dom4j;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.io.Writer;public class HrWriter {    public void writeXml(){        String file=&quot;C:\\Users\\Lenovo\\Desktop\\xml\\src\\haha.xml&quot;;        SAXReader reader=new SAXReader();        try {            Document document=reader.read(file);            Element root=document.getRootElement();            Element employee=root.addElement(&quot;employee&quot;);            employee.addAttribute(&quot;no&quot;,&quot;3311&quot;);            Element name=employee.addElement(&quot;name&quot;);            name.setText(&quot;李铁柱&quot;);            employee.addElement(&quot;salary&quot;).setText(&quot;3600&quot;);            Element department=employee.addElement(&quot;department&quot;);            department.addElement(&quot;dname&quot;).setText(&quot;人事部&quot;);            department.addElement(&quot;address&quot;).setText(&quot;XX大厦-B105&quot;);            Writer writer=new OutputStreamWriter(new FileOutputStream(file),&quot;UTF-8&quot;);            document.write(writer);            writer.close();        } catch (Exception e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        HrWriter hrWriter=new HrWriter();        hrWriter.writeXml();    }}</code></pre><h3 id="XPath实验室"><a href="#XPath实验室" class="headerlink" title="XPath实验室"></a>XPath实验室</h3><ul><li>利用Dom4j开发”XPath实验室”，一起见证XPath的神奇之处</li></ul><h4 id="Jaxen介绍"><a href="#Jaxen介绍" class="headerlink" title="Jaxen介绍"></a>Jaxen介绍</h4><ul><li>Jaxen是一个Java编写的开源的XPath库。这是适应多种不同的对象模型，包括DOM，XOM，dom4j和JDOM。</li><li>Dom4j底层依赖Jaxen实现XPath查询</li><li>下载地址:jaxen.codehaus.org</li></ul><pre><code class="java">package com.imooc.dom4j;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;import java.util.List;public class XPathTestor {    public void xpath(String xpathExp){        String file=&quot;C:\\Users\\Lenovo\\Desktop\\xml\\src\\haha.xml&quot;;        SAXReader reader=new SAXReader();        try {            Document document=reader.read(file);            List&lt;Node&gt; nodes=document.selectNodes(xpathExp);            for(Node node:nodes){                Element emp=(Element) node;                System.out.println(emp.attributeValue(&quot;no&quot;));                System.out.println(emp.elementText(&quot;name&quot;));                System.out.println(emp.elementText(&quot;age&quot;));                System.out.println(emp.elementText(&quot;salary&quot;));                System.out.println(&quot;=============================&quot;);            }        } catch (DocumentException e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        XPathTestor testor=new XPathTestor();        testor.xpath(&quot;/hr/employee&quot;);        testor.xpath(&quot;//employee&quot;);        testor.xpath(&quot;//employee[salary&lt;4000]&quot;);        testor.xpath(&quot;//employee[name=&#39;李铁柱&#39;]&quot;);        testor.xpath(&quot;//employee[@no=3304]&quot;);        testor.xpath(&quot;//employee[1]&quot;);        testor.xpath(&quot;//employee[last()]&quot;);        testor.xpath(&quot;employee[postion()&lt;6]&quot;);        testor.xpath(&quot;//employee[3]|//employee[8]&quot;);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
